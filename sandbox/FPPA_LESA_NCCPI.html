<!DOCTYPE HTML>
<html>
<head>
 <meta http-equiv="X-UA-Compatible" content="IE=edge"> 
	<title>NRCS Prime and other Important Farmlands</title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
</head>
<style type="text/css">

<style>

<style type="text/css">

<style>

<style type="text/css">
        .scrolltable {
            overflow-x: scroll;
            height: 100%;
            display: flex;
            display: -webkit-flex;
            flex-direction: column;
            -webkit-flex-direction: column;
        }
        .scrolltable > .header {
        }
        .scrolltable > .body {
            /*noinspection CssInvalidPropertyValue*/
            width: -webkit-fit-content;
            overflow-y: scroll;
            flex: 1;
            -webkit-flex: 1;
        }
        th, td {
            min-width: 25px;
        }
        /* an outside constraint to react against */
        #constrainer {
            width: 400px;
            height: 200px;
        }
        #constrainer2 {
            width: 400px;
            overflow-x: scroll;
        }
        #constrainer2 table {
            overflow-y: scroll;
        }
        #constrainer2 tbody {
            overflow-x: scroll;
            display: block;
            height: 200px;
        }
        #constrainer2 thead {
            display: table-row;
        }
        /* only styling below here */
        #constrainer, #constrainer2 {
            border: 1px solid lightgrey;
        }
        table {
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid gray;
        }
        th {
            background-color: lightgrey;
            border-width: 1px;
        }
        td {
            border-width: 1px;
        }
        tr:first-child td {
            border-top-width: 0;
        }
        tr:nth-child(even) {
            background-color: #eee;
        }
    </style>



<body>
<!--<img src="https://websoilsurvey.sc.egov.usda.gov/App/Resources/HomePage/images/WSSMasthead4.png" alt="WSS Logo" style="width:650px;height:150px;"> -->

--

	<h3>Soil Data Access (SDA) Farmland Protection Policy Act-LESA  Using NCCPI - National Commodity Crop Productivity Index (Ver 2.0)</h3>
	<p>
	An SDA-populated select list is used to pick a state and SSA which enables creation of a "Farmland Protection Policy Act - LESA" based upon those selections using the NCCPI. The data is not static; it hits Soil Data Access Live. To reset the table hit F5 on the keyboard. Once a survey is selected and table appears, if a new survey is selected it will append to the table at the bottom. Note: this report takes a few seconds longer to run. If they table doesn't appear right away please be patient. 
	<a href='#reportref'> For more information about the table, </a>
	</p>
	<a name='top'>
	<!-- The following "div" tag will be updated with the retrieved data
		After the first selection the "(select a state)" will disappear -->
	<select id="selectId1" onchange="ChangeSelectedState(event)">
		<option value='' style="display: none" id="remove">(select a state)</option>
	</select>
	
	<div id="selectedStateId"><p>(no state selected)</p></div>
	
	<select id="selectId2" onchange="ChangeSelectedSSA(event)">
		<option value='' style="display: none" id="remove">(select a soil survey area)</option>
	</select>
	
	<div id="selectedSSAId"><p>(no SSA selected)</p></div>
	
	<div class="container" id="id1"></div>
	<br></br
	<b>
		<font color='red'>
			<a name='reportref'>Report Metadata:</a>
		</font>
	</b>
	<php>
		<a href='#top'>Back to top</a>
	</php>
	<ul>
	<li><b>AREA_SYMBOL: </b>A symbol that uniquely identifies a single occurrence of a particular type of area (e.g. Soil Survey Area: Dane Co., Wisconsin is WI025).</li>
<li><b>STATE_SYMBOL: </b>A symbol that uniquely identifies a single occurrence of a particular type of area (e.g. State Symbol: Wisconsin is WI).</li>	
<li><b>AREA_NAME: </b> The name given to the specified geographic area. (e.g. Soil Survey Area Name: Dane County, WI). </li>	
<li><b>county_sym: </b>A symbol that uniquely identifies a single occurrence of a particular type of area (e.g. County Area: Dane Co., Wisconsin is WI025).</li>	
<li><b>county_nm: </b> The name given to the specified geographic area. (e.g. County Name: Dane County, WI).</li>	
<li><b>MUKEY</b> A non-connotative string of characters used to uniquely identify a record in the Mapunit table. </li>
<li><b>mucompkey: </b>> A non-connotative string of characters used to uniquely identify a record in the Mapunit table and component table.</li>
	
<li><b>MAP_UNIT_NAME:  </b> Correlated name of the mapunit (recommended name or field name for surveys in progress).</li>
<li><b>compname: </b>Name assigned to a component based on its range of properties. </li>	
<li><b>comp_pct: </b>	The percentage of the component of the mapunit. (RV) </li>
<li><b>MUSYM: </b> The symbol used to uniquely identify the soil mapunit in the soil survey. The Map Unit Symbols are just symbols displayed on a map and link to data. A map unit symbol is used to uniquely identify the soil Mapunit in the soil survey and not id’s. They are a way to link the spatial data to tabular data and does not necessary have any meaning except to provide someone a way to look up the tabular data. </li>
<li><b>FARM_CLASS: </b>Prime and other Important Farmlands- identification of map units as prime farmland, farmland of statewide importance, or farmland of local importance.</li>
<li><b>LCC: </b>The broadest category in the land capability classification system for nonirrigated soils. </li>
<li><b>SLOPE_RANGE: </b>The difference in elevation between two points, expressed as a percentage of the distance between those points. (SSM). Low, RV, High. </li>	
<li><b>MAP_UNIT_ACRES: </b>	The number of acres of a particular mapunit. </li>
<li><b>PCT_ACRES: </b>The percent acres for a map unit in area. </li>	
<li><b>SUM_ACRES: </b>The sum acres for the entire area. </li>	
<li><b>NCCPI_CROP_MAX: </b>	Highest value for the Crop index for multiple crops. </li>
<li><b>MIN_VALUE_LEGEND_CROP: </b>The lowest Crop Index value for a legend.</li>
<li><b>MAX_VALUE_LEGEND_CROP: </b> The highest Crop Index value for a legend. </li>
	
<li><b>LE: </b>The “LE” Value for LESA. </li>
	</ul>

	<b>
		<font color='red'>
			<a name='reportref'>Farmland Protection Policy Act-LESA  Description:</a>
		</font>
	</b>	
	
	


<ul>
<li>
Used for LESA Worksheet, by County Area Overlaps 
</li>
<li>
Also normalizes the productivity by County
</li>
<li>
LE (land evaluation) part of LESA - site assessment (as per the name) must be done on a site. Specific basis since it includes things like Ag infrastructure etc.. AND FPPA
</li>
</ul>

<p> The primary need for a LESA System in the state is for use in ranking soil survey map units to make farmland suitability assessments for the Farmland Protection Policy Act (FPPA). Prior to this new system, ranking sheets that were developed for soil survey legends that were available in the early 80's have been used for this purpose. Problems with these ranking sheets were that many state soil survey legends have been completed or updated since that time, and the ranking sheets had not been updated with the new soil survey legend information. As such, the 30 year old ranking sheets have gaps in the data and no longer agree with the current, official soil survey data that are currently presented on the Web Soil Survey. In addition, the ranking sheets utilized crop yield estimates from the original soil surveys as part of the ranking criteria. Over the years, those crop yield data have not been updated to reflect current improvements in crop genetics and agricultural practices, so the yield estimates are now very dated and inconsistent Statewide.
</p>
<p>This new Statewide LESA System corrects these deficiencies in the old ranking sheets. It utilizes a crop suitability ranking index that was developed for soils which is based on the soil properties in the official soil survey database, rather than the stored crop yield estimates. In addition, it is run on the same official soil survey data that are used by the Web Soil Survey. As such, it can provide a consistent, science based agricultural suitability ranking for soils of the state which can be refreshed very quickly as the official soil survey data are updated annually.
	</p>
<p>	
The new Statewide LESA System assigns the official map units for each Soil Survey Area into one of 20 groupings, with group one being the map units in the soil survey area with the best suitability for agricultural land uses, and group 20 being the least suited. The groupings are generated independently for each soil survey area so that each area will have some map unit(s) in the highest group and some map unit(s) in the lowest group. This remains consistent with the method that was used on the original ranking sheets. Each group is then assigned a relative value (rv) number which is 100 for group 1, 0 for groups 17 through 20, and increments between 0 and 100 for all other groups. These "RV" numbers are used to calculate rankings for the FPPA evaluations.	
</p>
	<script>
		var url =  "HTTPS://sdmdataaccess.sc.egov.usda.gov/tabular/post.rest";
		var stateId = "";
		// Wait for everything to be loaded before starting the first SDA request
		$(document).ready(function(){
			// Start by retrieving a state list
			var data = {
				query: "select statename, stateid from state order by statename;",
				format: "json"
			}
			$.post(url, data, function( callbackData ) {
					loadSelect("selectId1", callbackData.Table, 1, 0, "select a state");
				}, 
				"json");
		});
		
		function loadSelect(id, table, valueColumn, labelColumn, hintOption) {
			// Add options to the specified select list. The content of the table[valueColumn]
			// defines the value of the selection, the table[labelColumn] is used for the 
			// displayed option's text.
			var iRow = 0;
			$("#" + id)[0].innerHTML = "<option value='' style='display: none' id='remove'>(" + hintOption + ")</option>";
			while (iRow < table.length) {
				var row = table[iRow];
				var optionHtml = "<option value='" + row[valueColumn] + "'>" + row[labelColumn] + "</option>";
				$("#" + id).append(optionHtml);
				iRow++;
			}
		}
		
		function ChangeSelectedState(event) {
			// Update the selected state text area and then fetch SSA names and symbols
			var stateId = event.target.value;
			var notification = $("#selectedStateId");
			notification[0].innerHTML = "<p>selected stateId = " + stateId + "</p>";
			
			query =
				"SELECT distinct c.areaname, c.areasymbol "
				+ "FROM [dbo].[sastatusmap] c, [dbo].[saspatialver] s "
				+ "WHERE s.areasymbol = c.areasymbol "
				+ "AND c.areasymbol IN ("
				+ "SELECT DISTINCT l.areasymbol "
				+ "FROM [dbo].[legend] l, [dbo].[laoverlap] o "
				+ "WHERE o.lkey = l.lkey "
				+ "AND o.areatypename = 'State or Territory' "
				+ "AND o.areasymbol = '" + stateId + "' ) "
				+ "order by c.areaname, c.areasymbol;"
				
				
				;

			var data = {
				query: query,
				format: "json"
			}
			
			$.post(url, data, function( callbackData ) {
					loadSelect("selectId2", callbackData.Table, 1, 0, "select an SSA");
				}, 
				"json");
		}
		
		function ChangeSelectedSSA(event) {
			// Update the selected SSA text area and then fetch and display report 2 results
			var ssaId = event.target.value;
			var notification = $("#selectedSSAId");
			notification[0].innerHTML = "<p>selected SSA areasymbol = " + ssaId + "</p>";
			
		query = 
"SELECT farmlndcl, cokey, comppct_r , compname, SUM(muacres) over(partition by l.lkey) as SUM_ACRES, CONCAT(mu.mukey, ' - ', cokey) AS mucompkey, mu.muname, mop.mukey AS map_key, LEFT((l.areasymbol), 2) AS state_sym, CAST ((SELECT TOP 1 MIN (DISTINCT slope_l) FROM mapunit AS m_sl INNER JOIN component AS c_sl ON m_sl.mukey = c_sl.mukey  AND majcompflag = 'yes'  AND m_sl.mukey=mu.mukey GROUP BY m_sl.mukey) AS varchar) + '-' + CAST ((SELECT TOP 1 MAX (DISTINCT slope_h) FROM mapunit AS m_sh INNER JOIN  component AS c_sh ON m_sh.mukey = c_sh.mukey AND majcompflag = 'yes' AND m_sh.mukey=mu.mukey GROUP BY m_sh.mukey) AS varchar (3)) AS slope, l.lkey, CASE WHEN nirrcapscl IS NULL THEN nirrcapcl ELSE nirrcapcl + nirrcapscl END AS LCC, mu.musym, mu.mukey, mu.muacres, LEFT((l.areasymbol), 2) AS state, l.areasymbol, l.areaname, lap.areasymbol AS county_sym, lap.areaname AS county_nm,  (SELECT TOP 1 MIN(DISTINCT interphr)  FROM legend INNER JOIN  mapunit ON mapunit.lkey = legend.lkey AND legend.lkey=l.lkey INNER JOIN muaoverlap ON mapunit.mukey=muaoverlap.mukey INNER JOIN laoverlap ON muaoverlap.lareaovkey=laoverlap.lareaovkey AND laoverlap.areatypename = 'County or Parish'  AND laoverlap.lareaovkey= lap.lareaovkey INNER JOIN component ON component.mukey = mapunit.mukey INNER JOIN cointerp ON component.cokey = cointerp.cokey AND majcompflag = 'yes' AND ruledepth = 1 AND mrulename = 'NCCPI - National Commodity Crop Productivity Index (Ver 2.0)' GROUP BY laoverlap.lareaovkey ) as MIN_AREA,  (SELECT TOP 1 MAX (DISTINCT interphr)  FROM legend INNER JOIN  mapunit ON mapunit.lkey = legend.lkey AND legend.lkey=l.lkey INNER JOIN muaoverlap ON mapunit.mukey=muaoverlap.mukey INNER JOIN laoverlap ON muaoverlap.lareaovkey=laoverlap.lareaovkey AND laoverlap.areatypename = 'County or Parish'  AND laoverlap.lareaovkey= lap.lareaovkey INNER JOIN component ON component.mukey = mapunit.mukey INNER JOIN cointerp ON component.cokey = cointerp.cokey AND majcompflag = 'yes' AND ruledepth = 1 AND mrulename = 'NCCPI - National Commodity Crop Productivity Index (Ver 2.0)' GROUP BY laoverlap.lareaovkey ) as MAX_AREA, (SELECT MAX (interphr) FROM component INNER JOIN  cointerp ON component.cokey = cointerp.cokey  AND component.cokey = c.cokey AND ruledepth = 1 AND mrulename like 'NCCPI - National Commodity Crop Productivity Index (Ver 2.0)' ) AS NCCPI_Corn_Value_dcp  INTO #NCCPI FROM laoverlap AS lap INNER JOIN muaoverlap AS mop ON mop.lareaovkey=lap.lareaovkey AND lap.areatypename = 'County or Parish' INNER JOIN mapunit AS mu ON mu.mukey=mop.mukey INNER JOIN legend AS l ON l.lkey=mu.lkey "
+"		AND  l.areasymbol = '"  + ssaId + "'"
+"INNER JOIN  component AS c ON c.mukey = mu.mukey  AND c.cokey = (SELECT TOP 1 c1.cokey FROM component AS c1 INNER JOIN mapunit ON c.mukey=mapunit.mukey AND c1.mukey=mu.mukey ORDER BY c1.comppct_r DESC, c1.cokey) "
+"SELECT  DISTINCT #NCCPI.mukey AS map_key2, #NCCPI.mukey AS MKEY2, CASE WHEN muacres IS NULL THEN '0%' ELSE REPLACE ((CAST (ROUND ((CAST (CAST (ISNULL (muacres, 0)/1 AS decimal (10,3)) /CAST (SUM_ACRES/1 AS decimal (10,3)) AS decimal(10,3))) * 100, 2) AS VARCHAR) + '%') ,'00%', '%') END AS PCT_ACRES, MIN_AREA+((MAX_AREA-MIN_AREA)/20) AS GROUP20, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*2) AS GROUP19, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*3) AS GROUP18, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*4) AS GROUP17, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*5) AS GROUP16, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*6) AS GROUP15, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*7) AS GROUP14, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*8) AS GROUP13, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*9) AS GROUP12, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*10) AS GROUP11, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*11) AS GROUP10, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*12) AS GROUP09, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*13) AS GROUP08, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*14) AS GROUP07, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*15) AS GROUP06, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*16) AS GROUP05, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*17) AS GROUP04, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*18) AS GROUP03, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*19) AS GROUP02, MIN_AREA+(((MAX_AREA-MIN_AREA)/20)*20) AS GROUP01 INTO #NCCPI2 FROM #NCCPI SELECT DISTINCT areasymbol AS AREA_SYMBOL,  state_sym AS STATE_SYMBOL, areaname AS AREA_NAME,  county_sym, county_nm, mukey AS MUKEY, mucompkey, muname AS MAP_UNIT_NAME, compname, comppct_r AS comp_pct , musym AS MUSYM,  farmlndcl AS FARM_CLASS, LCC, slope AS SLOPE_RANGE, muacres AS MAP_UNIT_ACRES, PCT_ACRES, SUM_ACRES, NCCPI_Corn_Value_dcp AS NCCPI_CROP_MAX, MIN_AREA AS MIN_VALUE_LEGEND_CROP, MAX_AREA AS MAX_VALUE_LEGEND_CROP, CASE WHEN [NCCPI_Corn_Value_dcp]<=[GROUP20] THEN 0 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP20] AND[NCCPI_Corn_Value_dcp] <=[GROUP19])  THEN 5 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP19] AND[NCCPI_Corn_Value_dcp] <=[GROUP18])  THEN 10 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP18] AND[NCCPI_Corn_Value_dcp] <=[GROUP17])  THEN 15 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP17] AND[NCCPI_Corn_Value_dcp] <=[GROUP16])  THEN 20 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP16] AND[NCCPI_Corn_Value_dcp] <=[GROUP15])  THEN 25 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP15] AND[NCCPI_Corn_Value_dcp] <=[GROUP14])  THEN 30 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP14] AND[NCCPI_Corn_Value_dcp] <=[GROUP13])  THEN 35 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP13] AND[NCCPI_Corn_Value_dcp] <=[GROUP12])  THEN 40 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP12] AND[NCCPI_Corn_Value_dcp] <=[GROUP11])  THEN 45 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP11] AND[NCCPI_Corn_Value_dcp] <=[GROUP10])  THEN 50 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP10] AND[NCCPI_Corn_Value_dcp] <=[GROUP09])  THEN 55 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP09] AND[NCCPI_Corn_Value_dcp] <=[GROUP08])  THEN 60 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP08] AND[NCCPI_Corn_Value_dcp] <=[GROUP07])  THEN 65 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP07] AND[NCCPI_Corn_Value_dcp] <=[GROUP06])  THEN 70 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP06] AND[NCCPI_Corn_Value_dcp] <=[GROUP05])  THEN 75 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP05] AND[NCCPI_Corn_Value_dcp] <=[GROUP04])  THEN 80 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP04] AND[NCCPI_Corn_Value_dcp] <=[GROUP03])  THEN 85 WHEN ([NCCPI_Corn_Value_dcp]>[GROUP03] AND[NCCPI_Corn_Value_dcp] <=[GROUP02])  THEN 90 WHEN [NCCPI_Corn_Value_dcp]>=[GROUP20] THEN 100 ELSE 0 END AS LE FROM #NCCPI2 INNER JOIN #NCCPI ON #NCCPI.mukey = #NCCPI2.MKEY2  ORDER BY #NCCPI.state_sym, #NCCPI.county_sym, #NCCPI.county_nm, #NCCPI.areasymbol, #NCCPI.areaname, #NCCPI.mukey, #NCCPI.musym, #NCCPI.NCCPI_Corn_Value_dcp, #NCCPI.compname, #NCCPI.comppct_r, #NCCPI.mucompkey, PCT_ACRES, #NCCPI.SUM_ACRES, MAP_UNIT_ACRES, #NCCPI.MIN_AREA, #NCCPI.MAX_AREA , #NCCPI.LCC"

;
			
				var data = {
				query: query,
				format: "json+columnname"
			}
			
			$.post(url, data, function( callbackData ) {
				// the success callback function: when executed add content to table
					$('#id1')[0].innerHTML = "";
					var tableHtml = '<table border="1">';
					// for each row...
					var iRow = 0;
					while (iRow < callbackData.Table.length) {
						var row = callbackData.Table[iRow];
						tableHtml += "<tr>";
						// for each column in each row...
						var iCol = 0;
						while (iCol < row.length) {
							tableHtml += "<td>" + row[iCol] + "</td>";
							iCol++;
						};
						tableHtml += "</tr>";				
						iRow++;
					};
					tableHtml += '</table>'
					$('#id1').append(tableHtml);
				}, 
				// Specify that we want the request to be sent in JSON format
				"json");			
			
				
		}
	</script>
	
<script>
$(function(){
	$('table').each(function() {
		if($(this).find('thead').length > 0 && $(this).find('th').length > 0) {
			// Clone <thead>
			var $w	   = $(window),
				$t	   = $(this),
				$thead = $t.find('thead').clone(),
				$col   = $t.find('thead, tbody').clone();

			// Add class, remove margins, reset width and wrap table
			$t
			.addClass('sticky-enabled')
			.css({
				margin: 0,
				width: '100%'
			}).wrap('<div class="sticky-wrap" />');

			if($t.hasClass('overflow-y')) $t.removeClass('overflow-y').parent().addClass('overflow-y');

			// Create new sticky table head (basic)
			$t.after('<table class="sticky-thead" />');

			// If <tbody> contains <th>, then we create sticky column and intersect (advanced)
			if($t.find('tbody th').length > 0) {
				$t.after('<table class="sticky-col" /><table class="sticky-intersect" />');
			}

			// Create shorthand for things
			var $stickyHead  = $(this).siblings('.sticky-thead'),
				$stickyCol   = $(this).siblings('.sticky-col'),
				$stickyInsct = $(this).siblings('.sticky-intersect'),
				$stickyWrap  = $(this).parent('.sticky-wrap');

			$stickyHead.append($thead);

			$stickyCol
			.append($col)
				.find('thead th:gt(0)').remove()
				.end()
				.find('tbody td').remove();

			$stickyInsct.html('<thead><tr><th>'+$t.find('thead th:first-child').html()+'</th></tr></thead>');
			
			// Set widths
			var setWidths = function () {
					$t
					.find('thead th').each(function (i) {
						$stickyHead.find('th').eq(i).width($(this).width());
					})
					.end()
					.find('tr').each(function (i) {
						$stickyCol.find('tr').eq(i).height($(this).height());
					});

					// Set width of sticky table head
					$stickyHead.width($t.width());

					// Set width of sticky table col
					$stickyCol.find('th').add($stickyInsct.find('th')).width($t.find('thead th').width())
				},
				repositionStickyHead = function () {
					// Return value of calculated allowance
					var allowance = calcAllowance();
				
					// Check if wrapper parent is overflowing along the y-axis
					if($t.height() > $stickyWrap.height()) {
						// If it is overflowing (advanced layout)
						// Position sticky header based on wrapper scrollTop()
						if($stickyWrap.scrollTop() > 0) {
							// When top of wrapping parent is out of view
							$stickyHead.add($stickyInsct).css({
								opacity: 1,
								top: $stickyWrap.scrollTop()
							});
						} else {
							// When top of wrapping parent is in view
							$stickyHead.add($stickyInsct).css({
								opacity: 0,
								top: 0
							});
						}
					} else {
						// If it is not overflowing (basic layout)
						// Position sticky header based on viewport scrollTop
						if($w.scrollTop() > $t.offset().top && $w.scrollTop() < $t.offset().top + $t.outerHeight() - allowance) {
							// When top of viewport is in the table itself
							$stickyHead.add($stickyInsct).css({
								opacity: 1,
								top: $w.scrollTop() - $t.offset().top
							});
						} else {
							// When top of viewport is above or below table
							$stickyHead.add($stickyInsct).css({
								opacity: 0,
								top: 0
							});
						}
					}
				},
				repositionStickyCol = function () {
					if($stickyWrap.scrollLeft() > 0) {
						// When left of wrapping parent is out of view
						$stickyCol.add($stickyInsct).css({
							opacity: 1,
							left: $stickyWrap.scrollLeft()
						});
					} else {
						// When left of wrapping parent is in view
						$stickyCol
						.css({ opacity: 0 })
						.add($stickyInsct).css({ left: 0 });
					}
				},
				calcAllowance = function () {
					var a = 0;
					// Calculate allowance
					$t.find('tbody tr:lt(3)').each(function () {
						a += $(this).height();
					});
					
					// Set fail safe limit (last three row might be too tall)
					// Set arbitrary limit at 0.25 of viewport height, or you can use an arbitrary pixel value
					if(a > $w.height()*0.25) {
						a = $w.height()*0.25;
					}
					
					// Add the height of sticky header
					a += $stickyHead.height();
					return a;
				};

			setWidths();

			$t.parent('.sticky-wrap').scroll($.throttle(250, function() {
				repositionStickyHead();
				repositionStickyCol();
			}));

			$w
			.load(setWidths)
			.resize($.debounce(250, function () {
				setWidths();
				repositionStickyHead();
				repositionStickyCol();
			}))
			.scroll($.throttle(250, repositionStickyHead));
		}
	});
});
</script>
</body>
</html>
	
	</script>
</body>
</html>