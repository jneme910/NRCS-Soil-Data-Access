~DeclareChar(@attributeName,60)~
~DeclareChar(@ruleDesign,60)~
~DeclareChar(@ruleKey,30)~
~DeclareChar(@rating1,60)~
~DeclareChar(@rating2,60)~
~DeclareChar(@rating3,60)~
~DeclareChar(@rating4,60)~
~DeclareChar(@rating5,60)~
~DeclareChar(@rating6,60)~
~DeclareVarchar(@dateStamp,20)~
~DeclareInt(@minAcres)~
~DeclareInt(@minPct)~
~DeclareGeometry(@aoiGeom)~
~DeclareGeometry(@aoiGeomFixed)~
~DeclareChar(@ratingKey,70)~
~DeclareChar(@notRatedPhrase,15)~
~DeclareInt(@Level)~
 
-- Create AOI table with polygon geometry. Coordinate system must be WGS1984 (EPSG 4326)
CREATE TABLE #AoiTable 
    ( aoiid INT IDENTITY (1,1),
    landunit CHAR(20),
    aoigeom GEOMETRY);
 
-- Insert identifier string and WKT geometry for each AOI polygon after this...
 
SELECT @aoiGeom = GEOMETRY::STGeomFromText('MULTIPOLYGON (((-102.12335160658608 45.959173206572416, -102.13402890980223 45.959218442561564, -102.13386921506947 45.944643788188387, -102.12327175652177 45.944703605814198, -102.12335160658608 45.959173206572416)))', 4326);   
SELECT @aoiGeomFixed = @aoiGeom.MakeValid().STUnion(@aoiGeom.STStartPoint());  
INSERT INTO #AoiTable ( landunit, aoigeom )  
VALUES ('T9981 Fld3', @aoiGeomFixed); 
SELECT @aoiGeom = GEOMETRY::STGeomFromText('MULTIPOLYGON (((-102.1130336443976 45.959162795100383, -102.12335160658608 45.959173206572416, -102.12327175652177 45.944703605814198, -102.1128892282776 45.944710506326032, -102.1130336443976 45.959162795100383)))', 4326);   
SELECT @aoiGeomFixed = @aoiGeom.MakeValid().STUnion(@aoiGeom.STStartPoint());  
INSERT INTO #AoiTable ( landunit, aoigeom )  
VALUES ('T9981 Fld4', @aoiGeomFixed);
 
-- End of AOI geometry section
 
-- Create summary acres for each landunit 
CREATE TABLE #AoiAcres
    ( aoiid INT,
    landunit CHAR(20),
    landunit_acres FLOAT
    );
 
-- #LandunitRatingsDetailed1 table columns: landunit, attributename, rating, rating_num, rating_key, rating_pct, rating_acres, landunit_acres
CREATE TABLE #LandunitRatingsDetailed1
    (landunit CHAR(20),
    attributename CHAR(60),
    rating CHAR(60),
    rating_num INT,
    rating_key CHAR(60),
    rating_pct FLOAT,
    rating_acres FLOAT,
    landunit_acres FLOAT
    );
 
-- #LandunitRatingsDetailed2 table columns: landunit, attributename, rating, rating_num, rating_key, rating_pct, rating_acres, landunit_acres, rolling_pct, rolling_acres 
CREATE TABLE #LandunitRatingsDetailed2
    (landunit CHAR(20),
    attributename CHAR(60),
    rating CHAR(60),
    rating_num INT,
    rating_key CHAR(60),
    rating_pct FLOAT,
    rating_acres FLOAT,
    landunit_acres FLOAT,
    rolling_pct FLOAT,
    rolling_acres FLOAT
    );
 
-- #LandunitRatingsCART table columns: id, landunit, attributename, rating, rating_num, rating_key, rolling_pct, rolling_acres, landunit_acres
CREATE TABLE #LandunitRatingsCART
    (id INT,
    landunit CHAR(20),
    attributename CHAR(60),
    rating CHAR(60),
    -- rating_num INT,
    rating_key CHAR(60),
    rolling_pct FLOAT,
    rolling_acres FLOAT,
    landunit_acres FLOAT
    );
 
-- #LandunitRatingsCART table columns: id, landunit, attributename, rating, rating_num, rating_key, rolling_pct, rolling_acres, landunit_acres
-- This table will only contain the final, overall ratings for CART
CREATE TABLE #LandunitRatingsCART2
    (id INT IDENTITY (1,1),
    landunit CHAR(20),
    attributename CHAR(60),
    rating CHAR(60),
    rating_key CHAR(60),
    rolling_pct FLOAT,
    rolling_acres FLOAT,
    landunit_acres FLOAT,
    soils_metadata VARCHAR(150)
    );
 
-- Create intersected soil polygon table with geometry
CREATE TABLE #AoiSoils 
    ( polyid INT IDENTITY (1,1),
    aoiid INT,
    landunit CHAR(20),
    mukey INT,
    soilgeom GEOMETRY
    );
 
-- Soil geometry with landunits
CREATE TABLE #AoiSoils2 
    ( aoiid INT,
    polyid INT,
    landunit CHAR(20),
    mukey INT,
    poly_acres FLOAT,
    soilgeog GEOGRAPHY
    );
 
-- Soil map unit acres, aggregated by mukey (merges polygons together)
CREATE TABLE #M2
    ( aoiid INT,
    landunit CHAR(20),
    mukey INT,
    mapunit_acres FLOAT
    );

-- Component level data with cokey, comppct_r and mapunit sum-of-comppct_r (major components only)
CREATE TABLE #M4
(   aoiid INT,
    landunit CHAR(20),
    mukey INT,
    mapunit_acres FLOAT,
    cokey INT,
    compname CHAR(60),
    comppct_r INT,
    majcompflag CHAR(3)
    );

-- Component level ratings for the currently selected soil interpretation
CREATE TABLE #M5
   ( aoiid INT,
    landunit CHAR(20),
    mukey INT,
    mapunit_acres FLOAT,
    cokey INT,
    compname CHAR(60),
    comppct_r INT,
    rating CHAR(60),
    mu_pct_sum INT
    );
 
-- Component level ratings with adjusted component percent to account for missing minor components
-- #M6 columns: aoiid, landunit, mukey, mapunit_acres, cokey, compname, comppct_r, rating, MU_pct_sum, adj_comp_pct
CREATE TABLE #M6
   ( aoiid INT,
    landunit CHAR(20),
    mukey INT,
    mapunit_acres FLOAT,
    cokey INT,
    compname CHAR(60),
    comppct_r INT,
    rating CHAR(60),
    mu_pct_sum INT,
    adj_comp_pct FLOAT
    );
 
-- Component acres by multiplying map unit acres with adjusted component percent
-- #M8 columns:  aoiid, landunit, mukey, mapunit_acres, cokey, compname, comppct_r, rating, MU_pct_sum, adj_comp_pct, co_acres
CREATE TABLE #M8
    ( aoiid INT,
    landunit CHAR(20),
    mukey INT,
    mapunit_acres FLOAT,
    cokey INT,
    compname CHAR(60),
    comppct_r INT,
    rating CHAR(60),
    MU_pct_sum INT,
    adj_comp_pct FLOAT,
    co_acres FLOAT
    );
 
-- Aggregated rating class values and sum of component acres  by landunit (Tract and Field number)
CREATE TABLE #M10
    ( landunit CHAR(20),
    rating CHAR(60),
    rating_acres FLOAT
    );
 
-- Create a table containing neccessary interp data
-- Please note that if we instead get ruledesign from sdvattribute, those values change to integer as in 1:limitation, 2:suitability
CREATE TABLE #SDV
(rulekey VARCHAR(30),
attributename CHAR(60),
nasisrulename CHAR(60),
resultcolumnname CHAR(10),
ruledesign VARCHAR(60),
notratedphrase CHAR(15),
maplegendxml XML,

);
 
-- Create a table containing the first six rating classes for each interp
CREATE TABLE #RatingClasses
(attributename CHAR(60),
ruledesign CHAR(60),
rating1 CHAR(60),
rating2 CHAR(60),
rating3 CHAR(60),
rating4 CHAR(60),
rating5 CHAR(60),
rating6 CHAR(60)
);
 
-- Create a table containing the first six rating classes for each interp
CREATE TABLE #RatingDomain
(id INT IDENTITY (1,1),
rating_key CHAR(60),
attributename CHAR(60),
rating CHAR(60),
rating_num INT
);
 
-- Create table to store survey area datestamps (sacatalog.saverest)
CREATE TABLE #DateStamps
(landunit CHAR(20),
datestamp VARCHAR(32));
 
-- Create table to store landunit metadata (survey area and saverest) which comes from #DateStamps
CREATE TABLE #LandunitMetadata
(landunit CHAR(20),
soils_metadata VARCHAR(150)
);
 
-- End of CREATE TABLE section
 
-- Begin populating static tables. These are for the base soils data and metadata. No interp data yet.
--
-- Populate #SDV with interp metadata
INSERT INTO #SDV
  SELECT md.rulekey, sdv.attributename, sdv.nasisrulename,  sdv.resultcolumnname, md.ruledesign, sdv.notratedphrase, CAST(sdv.maplegendxml AS XML) AS maplegendxml
  FROM sdvattribute sdv
  INNER JOIN distinterpmd md ON sdv.nasisrulename = md.rulename
  WHERE sdv.attributename IN ('Agricultural Organic Soil Subsidence', 'Soil Susceptibility to Compaction', 'Organic Matter Depletion', 'Surface Salt Concentration')
  GROUP BY md.rulekey, sdv.attributename, sdv.nasisrulename, sdv.resultcolumnname, md.ruledesign, sdv.notratedphrase, sdv.maplegendxml;
 
INSERT INTO #AoiAcres (aoiid, landunit, landunit_acres )
    SELECT  aoiid, landunit,
    SUM( ROUND( ( ( GEOGRAPHY::STGeomFromWKB(aoigeom.STAsBinary(), 4326 ).STArea() ) / 4046.8564224 ), 3 ) ) AS landunit_acres
    FROM #AoiTable
    GROUP BY aoiid, landunit;
 
-- Populate intersected soil polygon table with geometry
INSERT INTO #AoiSoils (aoiid, landunit, mukey, soilgeom)
    SELECT A.aoiid, A.landunit, M.mukey, M.mupolygongeo.STIntersection(A.aoigeom ) AS soilgeom
    FROM mupolygon M, #AoiTable A
    WHERE mupolygongeo.STIntersects(A.aoigeom) = 1;
 
-- Populate Soil geometry with landunit attribute
INSERT INTO #AoiSoils2   
SELECT aoiid, polyid, landunit,  mukey, ROUND((( GEOGRAPHY::STGeomFromWKB(soilgeom.STAsBinary(), 4326 ).STArea() ) / 4046.8564224 ), 3 ) AS poly_acres, GEOGRAPHY::STGeomFromWKB(soilgeom.STAsBinary(), 4326 ) AS soilgeog 
FROM #AoiSoils;
 
-- Populate soil map unit acres, aggregated by mukey (merges polygons together)
INSERT INTO #M2
SELECT DISTINCT M1.aoiid, M1.landunit, M1.mukey,
ROUND (SUM (M1.poly_acres) OVER(PARTITION BY M1.landunit, M1.mukey), 3) AS mapunit_acres
FROM #AoiSoils2 AS M1
GROUP BY M1.aoiid, M1.landunit, M1.mukey, M1.poly_acres;
 
-- Populate component level data with cokey, comppct_r and mapunit sum-of-comppct_r
-- #M4 columns: aoiid, landunit, mukey, mapunit_acres, cokey, compname, comppct_r, majcompflag
INSERT INTO #M4
SELECT M2.aoiid, M2.landunit, M2.mukey, mapunit_acres, CO.cokey, CO.compname, CO.comppct_r, CO.majcompflag
FROM #M2 AS M2
INNER JOIN component AS CO ON CO.mukey = M2.mukey;

-- Get survey area dates for all soil mapunits involved
INSERT INTO #DateStamps
SELECT DISTINCT AM.landunit, ([SC].[areasymbol] + ' ' + CONVERT(VARCHAR(32),[SC].[saverest],120) ) AS datestamp
FROM #M4 AM
INNER JOIN mapunit Mu ON AM.mukey = Mu.mukey
INNER JOIN legend LG ON Mu.lkey = LG.lkey
INNER JOIN sacatalog SC ON Lg.areasymbol = SC.areasymbol;
 
-- Populate landunit soils-metadata
-- 
INSERT INTO #LandunitMetadata
SELECT DISTINCT
  landunit,
  STUFF((SELECT ' | ' + CAST([datestamp] AS VARCHAR(30))
    FROM #DateStamps dt2
    WHERE dt1.landunit = dt2.landunit
    FOR XML PATH ('') ), 1, 2, '') AS soils_metadata
FROM #DateStamps dt1;
 
-- END OF STATIC SECTION
-- ************************************************************************************************

-- ************************************************************************************************
-- BEGIN QUERIES FOR SOIL PROPERTIES HERE...
-- ************************************************************************************************

-- Hydric Rating begins here
-- Hydric soils at teh Map Unit, using all map units from table #M2.
CREATE TABLE #Hydric1
    (mukey INT, comp_count INT, count_maj_comp INT,	all_hydric INT,	maj_hydric INT,	maj_not_hydric INT,	hydric_inclusions INT,	all_not_hydric INT,	hydric_null INT);

--Determines the Hydric Rating and throws it into an interpretaion class
INSERT INTO #Hydric1 (mukey, comp_count,count_maj_comp,	all_hydric,	maj_hydric,	maj_not_hydric,	hydric_inclusions,	all_not_hydric,	hydric_null)
SELECT DISTINCT M4.mukey,   
(SELECT TOP 1 COUNT_BIG(*)
 FROM mapunit
 INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = M4.mukey) AS comp_count,
 (SELECT TOP 1 COUNT_BIG(*)
 FROM mapunit
 INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = M4.mukey
 AND majcompflag = 'Yes') AS count_maj_comp,
 (SELECT TOP 1 COUNT_BIG(*)
 FROM mapunit
 INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = M4.mukey
 AND hydricrating = 'Yes' ) AS all_hydric,
 (SELECT TOP 1 COUNT_BIG(*)
 FROM mapunit
 INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = M4.mukey
 AND majcompflag = 'Yes' AND hydricrating = 'Yes') AS maj_hydric,
 (SELECT TOP 1 COUNT_BIG(*)
 FROM mapunit
 INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = M4.mukey
 AND majcompflag = 'Yes' AND hydricrating != 'Yes') AS maj_not_hydric,
  (SELECT TOP 1 COUNT_BIG(*)
 FROM mapunit
 INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = M4.mukey
 AND majcompflag != 'Yes' AND hydricrating  = 'Yes' ) AS hydric_inclusions,
 (SELECT TOP 1 COUNT_BIG(*)
 FROM mapunit
 INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = M4.mukey
 AND hydricrating  != 'Yes') AS all_not_hydric, 
  (SELECT TOP 1 COUNT_BIG(*)
 FROM mapunit
 INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = M4.mukey
 AND hydricrating  IS NULL ) AS hydric_null 
FROM #M4 AS M4;

--Determins the Low, Rv, and Hight range for Hydric
--CREATE TABLE #Hydric2
  -- (mukey INT, hydric_rating CHAR (25), low_pct FLOAT, rv_pct FLOAT, high_pct FLOAT);

--INSERT INTO #Hydric2 (mukey, hydric_rating, low_pct, rv_pct, high_pct)

CREATE TABLE #Hydric2
    (mukey INT, hydric_rating CHAR (25), low_pct FLOAT, rv_pct FLOAT, high_pct FLOAT);

--Determines the Hydric Rating and throws it into an interpretaion class
INSERT INTO #Hydric2 (mukey, hydric_rating, low_pct, rv_pct, high_pct)
SELECT  
mukey,
CASE WHEN comp_count = all_not_hydric + hydric_null THEN  'Nonhydric' 
WHEN comp_count = all_hydric  THEN 'Hydric' 
WHEN comp_count != all_hydric AND count_maj_comp = maj_hydric THEN 'Predominantly Hydric' 
WHEN hydric_inclusions >= 0.5 AND  maj_hydric < 0.5 THEN  'Predominantly Nonydric' 
WHEN maj_not_hydric >= 0.5  AND  maj_hydric >= 0.5 THEN 'Partially Hydric' ELSE 'Error' END AS hydric_rating, 

CASE WHEN comp_count = all_not_hydric + hydric_null THEN 0.00 --'Nonhydric' 
WHEN comp_count = all_hydric  THEN 1 --'Hydric' 
WHEN comp_count != all_hydric AND count_maj_comp = maj_hydric THEN 0.80 --'Predominantly Hydric' 
WHEN hydric_inclusions >= 0.5 AND  maj_hydric < 0.5 THEN 0.01 --'Predominantly Nonydric' 
WHEN maj_not_hydric >= 0.5  AND  maj_hydric >= 0.5 THEN  0.15 --'Partially Hydric' 
ELSE 0.00--'Error' 
END AS low_pct, 

CASE WHEN comp_count = all_not_hydric + hydric_null THEN 0.00 --'Nonhydric' 
WHEN comp_count = all_hydric  THEN 1 --'Hydric' 
WHEN comp_count != all_hydric AND count_maj_comp = maj_hydric THEN 0.85 --'Predominantly Hydric' 
WHEN hydric_inclusions >= 0.5 AND  maj_hydric < 0.5 THEN 0.05 --'Predominantly Nonydric' 
WHEN maj_not_hydric >= 0.5  AND  maj_hydric >= 0.5 THEN  0.50 --'Partially Hydric' 
ELSE 0.00--'Error' 
END AS rv_pct, 

CASE WHEN comp_count = all_not_hydric + hydric_null THEN 0.00 --'Nonhydric' 
WHEN comp_count = all_hydric  THEN 1 --'Hydric' 
WHEN comp_count != all_hydric AND count_maj_comp = maj_hydric THEN 0.99 --'Predominantly Hydric' 
WHEN hydric_inclusions >= 0.5 AND  maj_hydric < 0.5 THEN 0.20 --'Predominantly Nonydric' 
WHEN maj_not_hydric >= 0.5  AND  maj_hydric >= 0.5 THEN  0.79 --'Partially Hydric' 
ELSE 0.00--'Error' 
END AS high_pct
FROM #Hydric1 AS H2;


CREATE TABLE #Hydric3
    (aoiid  INT , AOI_Acres FLOAT, landunit CHAR(20), mukey INT, Hydric_flag INT, low_acres FLOAT, rv_acres FLOAT, high_acres  FLOAT);
INSERT INTO #Hydric3 ( aoiid ,AOI_Acres, landunit , mukey, Hydric_flag, low_acres, rv_acres, high_acres)
SELECT DISTINCT aoiid , ROUND (SUM (mapunit_acres ) over(partition by aoiid),2) as AOI__acres,  landunit, H3.mukey,
CASE WHEN hydric_rating = 'Nonhydric' THEN 0 ELSE 1 END AS Hydric_flag,
mapunit_acres * low_pct AS low_acres, 
mapunit_acres * rv_pct AS rv_acres , 
mapunit_acres * high_pct AS high_acres  
FROM #Hydric2 AS H3
INNER JOIN #M2 AS MH2 ON MH2.mukey=H3.mukey
GROUP BY aoiid, landunit, H3.mukey, mapunit_acres, hydric_rating, low_pct, rv_pct, high_pct

SELECT DISTINCT landunit, 
ROUND (SUM (low_acres) over(partition by aoiid),2) as aoiid_low_acres, 
ROUND (SUM (rv_acres) over(partition by aoiid),2) as aoiid_rv_acres, 
ROUND (SUM (high_acres) over(partition by aoiid),2) as aoiid_high_acres,
ROUND((ROUND (SUM (low_acres) over(partition by aoiid),2)/AOI_Acres)*100, 2) AS aoiid_low_pct, 
ROUND((ROUND (SUM (rv_acres) over(partition by aoiid),2)/AOI_Acres)*100, 2) AS aoiid_rv_pct,
ROUND((ROUND (SUM (high_acres) over(partition by aoiid),2)/AOI_Acres)*100, 2)  AS aoiid_high_pct,
AOI_Acres
FROM #Hydric3 AS h3
 




 
--
-- Hydric Rating ends here
 
-- ************************************************************************************************
-- END OF QUERIES FOR SOIL PROPERTIES...
-- ************************************************************************************************
 
