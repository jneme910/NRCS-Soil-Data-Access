<!DOCTYPE HTML>
<html>
<head>
 <meta http-equiv="X-UA-Compatible" content="IE=edge"> 
	<title>NRCS Hydric Soils List</title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
	<script> function demoFromHTML() {
    var pdf = new jsPDF('p', 'pt', 'letter');
    // source can be HTML-formatted string, or a reference
    // to an actual DOM element from which the text will be scraped.
    source = $('#customers')[0];

    // we support special element handlers. Register them with jQuery-style 
    // ID selector for either ID or node name. ("#iAmID", "div", "span" etc.)
    // There is no support for any other type of selectors 
    // (class, of compound) at this time.
    specialElementHandlers = {
        // element with id of "bypass" - jQuery style selector
        '#bypassme': function (element, renderer) {
            // true = "handled elsewhere, bypass text extraction"
            return true
        }
    };
    margins = {
        top: 80,
        bottom: 60,
        left: 10,
        width: 700
    };
    // all coords and widths are in jsPDF instance's declared units
    // 'inches' in this case
    pdf.fromHTML(
    source, // HTML string or DOM elem ref.
    margins.left, // x coord
    margins.top, { // y coord
        'width': margins.width, // max width of content on PDF
        'elementHandlers': specialElementHandlers
    },

    function (dispose) {
        // dispose: object with X, Y of the last line add to the PDF 
        //          this allow the insertion of new lines after html
        pdf.save('Test.pdf');
    }, margins);
}
</script>
</head>
<style type="text/css">

<style>

<style type="text/css">

<style>

	<style type="text/css">
        .scrolltable {
            overflow-x: scroll;
            height: 100%;
            display: flex;
            display: -webkit-flex;
            flex-direction: column;
            -webkit-flex-direction: column;
        }
        .scrolltable > .header {
        }
        .scrolltable > .body {
            /*noinspection CssInvalidPropertyValue*/
            width: -webkit-fit-content;
            overflow-y: scroll;
            flex: 1;
            -webkit-flex: 1;
        }
        th, td {
            min-width: 25px;
        }
        /* an outside constraint to react against */
        #constrainer {
            width: 400px;
            height: 200px;
        }
        #constrainer2 {
            width: 400px;
            overflow-x: scroll;
        }
        #constrainer2 table {
            overflow-y: scroll;
        }
        #constrainer2 tbody {
            overflow-x: scroll;
            display: block;
            height: 200px;
        }
        #constrainer2 thead {
            display: table-row;
        }
        /* only styling below here */
        #constrainer, #constrainer2 {
            border: 1px solid lightgrey;
        }
        table {
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid gray;
        }
        th {
            background-color: lightgrey;
            border-width: 1px;
        }
        td {
            border-width: 1px;
        }
        tr:first-child td {
            border-top-width: 0;
        }
        tr:nth-child(even) {
            background-color: #d9e0f9;
        }
    </style>


<body>
<!--<img src="https://websoilsurvey.sc.egov.usda.gov/App/Resources/HomePage/images/WSSMasthead4.png" alt="WSS Logo" style="width:650px;height:150px;"> -->

<hr style="border: none; border-bottom: 4px solid grey;">
<font color="blue">
		<h2>Soil Survey Area - Soil Data Access (SDA) - Hydric Soils Rating by Map Unit</h2>
		</font>
	


	<p>An SDA-populated select list is used to pick a state and SSA which enables creation of a "Hydric Soils Report" based upon those selections. The data is not static; it hits Soil Data Access Live. To reset the table change the state dropdown. Once a state is selected and table appears, if a new state is selected it will refresh the table. The report uses a count instead of component percent to determine the hydric rating by map unit. 


	<a href='#reportref'> For more information about the table, </a>
	</p>
	<a name='top'>

	<!-- The following "div" tag will be updated with the retrieved data
		After the first selection the "(select a state)" will disappear -->
	<select id="selectId1" onchange="ChangeSelectedState(event)">
		<option value='' style="display: none" id="remove">(select a state)</option>
	</select>
	
	<div id="selectedStateId"><p>(no state selected)</p></div>
	
	<select id="selectId2" onchange="ChangeSelectedSSA(event)">
		<option value='' style="display: none" id="remove">(select a soil survey area)</option>
	</select>
	
	<div id="selectedSSAId"><p>(no SSA selected)</p></div>
	
	<div class="container" id="id1"></div>
	<br></br>

	<b>
		<font color='red'>
			<a name='reportref'>Report Metadata:</a>
		</font>
	</b>
	<php>
		<a href='#top'>Back to top</a>
	</php>
		<ul>
	<li><b>areasymbol: </b>A symbol that uniquely identifies a single occurrence of a particular type of area (e.g. Dane Co., Wisconsin is WI025).</li>
	<li><b>musym: </b> The symbol used to uniquely identify the soil mapunit in the soil survey.</li>
	<li><b>Mapunit_Name: </b> Correlated name of the mapunit (recommended name or field name for surveys in progress).</li>
	<li><b>mukey: </b> A non-connotative string of characters used to uniquely identify a record in the Mapunit table.</li>
	<li><b>hydric_rating: </b> This Hydric Soil Category rating indicates the components of map units that meet the criteria for hydric soils. </li>
		</ul>

	<b>
		<font color='red'>
			<a name='reportref'>Hydric Soil Categories  :</a>
		</font>
	</b>	
	
<p> This Hydric Soil Category rating indicates the components of map units that meet the criteria for hydric soils. Map units are composed of one or more major soil components or soil types that generally make up 20 percent or more of the map unit and are listed in the map unit name, and they may also have one or more minor contrasting soil components that generally make up less than 20 percent of the map unit. Each major and minor map unit component that meets the hydric criteria is rated 
<span class="bold">hydric. </span> The map unit class ratings based on the hydric components present are: Hydric, Predominantly Hydric, Partially Hydric, Predominantly Nonhydric, and Nonhydric. The report also shows the total representative percentage of each map unit that the hydric components comprise.</p><p>
<ul>
 <li><b><span class="italic">"Hydric"</span></b> means that all major and minor components listed for a given map unit are rated as being hydric. </li>
 <li><b><span class="italic">"Predominantly Hydric"</span></b> means that all major components listed for a given map unit are rated as hydric, and at least one contrasting minor component is not rated hydric.</li>
 <li><b><span class="italic">"Partially Hydric" </span></b>means that at least one major component listed for a given map unit is rated as hydric, and at least one other major component is not rated hydric. </li>
 <li><b><span class="italic">"Predominantly Nonhydric" </span> </b>means that no major component listed for a given map unit is rated as hydric, and at least one contrasting minor component is rated hydric.</li> 
 <li><b><span class="italic">"Nonhydric" </span></b>means no major or minor components for the map unit are rated hydric. The assumption is that the map unit is nonhydric even if none of the components within the map unit have been rated.</li>
</ul>
</p><p> Hydric soils are defined by the National Technical Committee for Hydric Soils (NTCHS) as soils that formed under conditions of saturation, flooding, or ponding long enough during the growing season to develop anaerobic conditions in the upper part (Federal Register, 1994). Under natural conditions, these soils are either saturated or inundated long enough during the growing season to support the growth and reproduction of hydrophytic vegetation. </p><p>If soils are wet enough for a long enough period of time to be considered hydric, they typically exhibit certain properties that can be easily observed in the field. These visible properties are indicators of hydric soils. The indicators used to make onsite determinations of hydric soils are specified in "Field Indicators of Hydric Soils in the United States" (Vasilas, Hurt, and Noble, 2010).</p><p>The NTCHS has developed criteria to identify those soil properties unique to hydric soils (Federal Register, 2012). These criteria are used to identify map unit components that normally are associated with wetlands. The criteria use selected soil properties that are described in “Field Indicators of Hydric Soils in the United States” (Vasilas, Hurt, and Noble, 2010), "Soil Taxonomy" (Soil Survey Staff, 1999), "Keys to Soil Taxonomy" (Soil Survey Staff, 2010), and the "Soil Survey Manual" (Soil Survey Division Staff, 1993).</p><p>The criteria for hydric soils are represented by codes, for example, 2 or 3. Definitions for the codes are as follows:</p>                    <ol>
                      <li>
<p>All Histels except for Folistels, and Histosols except for Folists.</p>                      </li>
                      <li>
<p> Soils in Aquic suborders, great groups, or subgroups, Albolls suborder, Historthels great group, Histoturbels great group, Pachic subgroups, or Cumulic subgroups that:        </p><ol><li><p>Based on the range of characteristics for the soil series, will at least in part meet one or more Field Indicators of Hydric Soils in the United States, or </p></li><li><p>Show evidence that the soil meets the definition of a hydric soil;</p></li></ol><p></p>                      </li>
                      <li>
<p>Soils that are frequently ponded for long or very long duration during the growing season.        </p><ol><li><p>Based on the range of characteristics for the soil series, will at least in part meet one or more Field Indicators of Hydric Soils in the United States, or </p></li><li><p>Show evidence that the soil meets the definition of a hydric soil;</p></li></ol><p></p>                      </li>
                      <li>
<p>Map unit components that are frequently flooded for long duration or very long duration during the growing season that:</p><ol><li><p>Based on the range of characteristics for the soil series, will at least in part meet one or more Field Indicators of Hydric Soils in the United States, or </p></li><li><p>Show evidence that the soil meets the definition of a hydric soil;</p></li></ol><p></p>                      </li>
                    </ol>
<p>Hydric Condition: Food Security Act information regarding the ability to grow a commodity crop without removing woody vegetation or manipulating hydrology.</p><p>References:</p>                    <ul class="noimage">
                      <li>
<span class="italic"></span>                         
Federal Register. July 13, 1994. Changes in hydric soils of the United States.                      </li>
                      <li>
<span class="italic"></span>                         
Federal Register. February, 28, 2012. Hydric soils of the United States.                      </li>
                      <li>
<span class="italic"></span>                         
Soil Survey Division Staff. 1993. Soil survey manual. Soil Conservation Service. U.S. Department of Agriculture Handbook 18.                      </li>
                      <li>
<span class="italic"></span>                         
Soil Survey Staff. 1999. Soil taxonomy: A basic system of soil classification for making and interpreting soil surveys. 2nd edition. Natural Resources Conservation Service. U.S. Department of Agriculture Handbook 436.                      </li>
                      <li>
<span class="italic"></span>                         
Soil Survey Staff. 2010. Keys to soil taxonomy. 11th edition. U.S. Department of Agriculture, Natural Resources Conservation Service.                      </li>
                      <li>
<span class="italic"></span>                         
Vasilas, L.M., G.W. Hurt, and C.V. Noble, editors. Version 7.0, 2010. Field indicators of hydric soils in the United States.                      </li>
                    </ul>

	<script>
		var url =  "HTTPS://sdmdataaccess.sc.egov.usda.gov/tabular/post.rest";
		var stateId = "";
		// Wait for everything to be loaded before starting the first SDA request
		$(document).ready(function(){
			// Start by retrieving a state list
			var data = {
				query: "select statename, stateid from state order by statename;",
				format: "json"
			}
			$.post(url, data, function( callbackData ) {
					loadSelect("selectId1", callbackData.Table, 1, 0, "select a state");
				}, 
				"json");
		});
		
		function loadSelect(id, table, valueColumn, labelColumn, hintOption) {
			// Add options to the specified select list. The content of the table[valueColumn]
			// defines the value of the selection, the table[labelColumn] is used for the 
			// displayed option's text.
			var iRow = 0;
			$("#" + id)[0].innerHTML = "<option value='' style='display: none' id='remove'>(" + hintOption + ")</option>";
			while (iRow < table.length) {
				var row = table[iRow];
				var optionHtml = "<option value='" + row[valueColumn] + "'>" + row[labelColumn] + "</option>";
				$("#" + id).append(optionHtml);
				iRow++;
			}
		}
		
		function ChangeSelectedState(event) {
			// Update the selected state text area and then fetch SSA names and symbols
			var stateId = event.target.value;
			var notification = $("#selectedStateId");
			notification[0].innerHTML = "<p>selected stateId = " + stateId + "</p>";
			
			query =
				"SELECT distinct c.areaname, c.areasymbol "
				+ "FROM [dbo].[sastatusmap] c, [dbo].[saspatialver] s "
				+ "WHERE s.areasymbol = c.areasymbol "
				+ "AND c.areasymbol IN ("
				+ "SELECT DISTINCT l.areasymbol "
				+ "FROM [dbo].[legend] l, [dbo].[laoverlap] o "
				+ "WHERE o.lkey = l.lkey "
				+ "AND o.areatypename = 'State or Territory' "
				+ "AND o.areasymbol = '" + stateId + "' ) "
				+ "order by c.areaname, c.areasymbol;";

			var data = {
				query: query,
				format: "json"
			}
			
			$.post(url, data, function( callbackData ) {
					loadSelect("selectId2", callbackData.Table, 1, 0, "select an SSA");
				}, 
				"json");
		}
		
		function ChangeSelectedSSA(event) {
			// Update the selected SSA text area and then fetch and display report 2 results
			var ssaId = event.target.value;
			var notification = $("#selectedSSAId");
			notification[0].innerHTML = "<p>selected SSA areasymbol = " + ssaId + "</p>";
			
		query = 

" SELECT areasymbol, musym, muname, mu.mukey/1  AS mukey,"
+ " (SELECT TOP 1 COUNT_BIG(*)"
+ " FROM mapunit"
+ " INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = mu.mukey) AS comp_count,"
+ " (SELECT TOP 1 COUNT_BIG(*)"
+ " FROM mapunit"
+ " INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = mu.mukey"
+ " AND majcompflag = 'Yes') AS count_maj_comp,"
+ " (SELECT TOP 1 COUNT_BIG(*)"
+ " FROM mapunit"
+ " INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = mu.mukey"
+ " AND hydricrating = 'Yes' ) AS all_hydric,"
+ " (SELECT TOP 1 COUNT_BIG(*)"
+ " FROM mapunit"
+ " INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = mu.mukey"
+ " AND majcompflag = 'Yes' AND hydricrating = 'Yes') AS maj_hydric,"
+ " (SELECT TOP 1 COUNT_BIG(*)"
+ " FROM mapunit"
+ " INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = mu.mukey"
+ " AND majcompflag = 'Yes' AND hydricrating != 'Yes') AS maj_not_hydric,"
+ "   (SELECT TOP 1 COUNT_BIG(*)"
+ " FROM mapunit"
+ " INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = mu.mukey"
+ " AND majcompflag != 'Yes' AND hydricrating  = 'Yes' ) AS hydric_inclusions,"
+ " (SELECT TOP 1 COUNT_BIG(*)"
+ " FROM mapunit"
+ " INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = mu.mukey"
+ " AND hydricrating  != 'Yes') AS all_not_hydric, "
+ "   (SELECT TOP 1 COUNT_BIG(*)"
+ " FROM mapunit"
+ " INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = mu.mukey"
+ " AND hydricrating  IS NULL ) AS hydric_null "
+ "  INTO #main_query"
+ " FROM legend  AS l"
+ " INNER JOIN  mapunit AS mu ON mu.lkey = l.lkey AND  l.areasymbol = '"  + ssaId + "'"
+ " "
+ " SELECT  areasymbol, musym, muname, mukey,"
+ " CASE WHEN comp_count = all_not_hydric + hydric_null THEN  'Nonhydric' "
+ " WHEN comp_count = all_hydric  THEN 'Hydric' "
+ " WHEN comp_count != all_hydric AND count_maj_comp = maj_hydric THEN 'Predominantly Hydric' "
+ " WHEN hydric_inclusions >= 0.5 AND  maj_hydric < 0.5 THEN  'Predominantly Nonydric' "
+ " WHEN maj_not_hydric >= 0.5  AND  maj_hydric >= 0.5 THEN 'Partially Hydric' ELSE 'Error' END AS hydric_rating"
+ " FROM #main_query"
;			
					var data = {
				query: query,
				format: "json+columnname"
			}
			
			$.post(url, data, function( callbackData ) {
				// the success callback function: when executed add content to table
					$('#id1')[0].innerHTML = "";
					var tableHtml = '<table border="1">';
					// for each row...
		                var iRow = 0;
                while (iRow < callbackData.Table.length) {
                                var row = callbackData.Table[iRow];
                                tableHtml += "<tr>";
                                // for each column in each row...
                                var iCol = 0;
                                while (iCol < row.length) {
                                                if (iRow == 0) {
                                                                tableHtml += "<th>" + row[iCol] + "</th>";
                                                } else {
                                                                tableHtml += "<td>" + row[iCol] + "</td>";
                                                }
                                                iCol++;
                                };
                                tableHtml += "</tr>";                                  
                                iRow++;
                };

					tableHtml += '</table>'
					$('#id1').append(tableHtml);
				}, 
				// Specify that we want the request to be sent in JSON format
				"json");			
			
				
		}
	</script>
	
<script>
$(function(){
	$('table').each(function() {
		if($(this).find('thead').length > 0 && $(this).find('th').length > 0) {
			// Clone <thead>
			var $w	   = $(window),
				$t	   = $(this),
				$thead = $t.find('thead').clone(),
				$col   = $t.find('thead, tbody').clone();

			// Add class, remove margins, reset width and wrap table
			$t
			.addClass('sticky-enabled')
			.css({
				margin: 0,
				width: '100%'
			}).wrap('<div class="sticky-wrap" />');

			if($t.hasClass('overflow-y')) $t.removeClass('overflow-y').parent().addClass('overflow-y');

			// Create new sticky table head (basic)
			$t.after('<table class="sticky-thead" />');

			// If <tbody> contains <th>, then we create sticky column and intersect (advanced)
			if($t.find('tbody th').length > 0) {
				$t.after('<table class="sticky-col" /><table class="sticky-intersect" />');
			}

			// Create shorthand for things
			var $stickyHead  = $(this).siblings('.sticky-thead'),
				$stickyCol   = $(this).siblings('.sticky-col'),
				$stickyInsct = $(this).siblings('.sticky-intersect'),
				$stickyWrap  = $(this).parent('.sticky-wrap');

			$stickyHead.append($thead);

			$stickyCol
			.append($col)
				.find('thead th:gt(0)').remove()
				.end()
				.find('tbody td').remove();

			$stickyInsct.html('<thead><tr><th>'+$t.find('thead th:first-child').html()+'</th></tr></thead>');
			
			// Set widths
			var setWidths = function () {
					$t
					.find('thead th').each(function (i) {
						$stickyHead.find('th').eq(i).width($(this).width());
					})
					.end()
					.find('tr').each(function (i) {
						$stickyCol.find('tr').eq(i).height($(this).height());
					});

					// Set width of sticky table head
					$stickyHead.width($t.width());

					// Set width of sticky table col
					$stickyCol.find('th').add($stickyInsct.find('th')).width($t.find('thead th').width())
				},
				repositionStickyHead = function () {
					// Return value of calculated allowance
					var allowance = calcAllowance();
				
					// Check if wrapper parent is overflowing along the y-axis
					if($t.height() > $stickyWrap.height()) {
						// If it is overflowing (advanced layout)
						// Position sticky header based on wrapper scrollTop()
						if($stickyWrap.scrollTop() > 0) {
							// When top of wrapping parent is out of view
							$stickyHead.add($stickyInsct).css({
								opacity: 1,
								top: $stickyWrap.scrollTop()
							});
						} else {
							// When top of wrapping parent is in view
							$stickyHead.add($stickyInsct).css({
								opacity: 0,
								top: 0
							});
						}
					} else {
						// If it is not overflowing (basic layout)
						// Position sticky header based on viewport scrollTop
						if($w.scrollTop() > $t.offset().top && $w.scrollTop() < $t.offset().top + $t.outerHeight() - allowance) {
							// When top of viewport is in the table itself
							$stickyHead.add($stickyInsct).css({
								opacity: 1,
								top: $w.scrollTop() - $t.offset().top
							});
						} else {
							// When top of viewport is above or below table
							$stickyHead.add($stickyInsct).css({
								opacity: 0,
								top: 0
							});
						}
					}
				},
				repositionStickyCol = function () {
					if($stickyWrap.scrollLeft() > 0) {
						// When left of wrapping parent is out of view
						$stickyCol.add($stickyInsct).css({
							opacity: 1,
							left: $stickyWrap.scrollLeft()
						});
					} else {
						// When left of wrapping parent is in view
						$stickyCol
						.css({ opacity: 0 })
						.add($stickyInsct).css({ left: 0 });
					}
				},
				calcAllowance = function () {
					var a = 0;
					// Calculate allowance
					$t.find('tbody tr:lt(3)').each(function () {
						a += $(this).height();
					});
					
					// Set fail safe limit (last three row might be too tall)
					// Set arbitrary limit at 0.25 of viewport height, or you can use an arbitrary pixel value
					if(a > $w.height()*0.25) {
						a = $w.height()*0.25;
					}
					
					// Add the height of sticky header
					a += $stickyHead.height();
					return a;
				};

			setWidths();

			$t.parent('.sticky-wrap').scroll($.throttle(250, function() {
				repositionStickyHead();
				repositionStickyCol();
			}));

			$w
			.load(setWidths)
			.resize($.debounce(250, function () {
				setWidths();
				repositionStickyHead();
				repositionStickyCol();
			}))
			.scroll($.throttle(250, repositionStickyHead));
		}
	});
});
</script>
</body>
</html>