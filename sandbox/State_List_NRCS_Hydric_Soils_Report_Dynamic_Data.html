
<!DOCTYPE HTML>
<html>
<head>
 <meta http-equiv="X-UA-Compatible" content="IE=edge"> 
	<title>NRCS State Hydric Soils List</title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
	
	<style type="text/css">
        .scrolltable {
            overflow-x: scroll;
            height: 100%;
            display: flex;
            display: -webkit-flex;
            flex-direction: column;
            -webkit-flex-direction: column;
        }
        .scrolltable > .header {
        }
        .scrolltable > .body {
            /*noinspection CssInvalidPropertyValue*/
            width: -webkit-fit-content;
            overflow-y: scroll;
            flex: 1;
            -webkit-flex: 1;
        }
        th, td {
            min-width: 25px;
        }
        /* an outside constraint to react against */
        #constrainer {
            width: 400px;
            height: 200px;
        }
        #constrainer2 {
            width: 400px;
            overflow-x: scroll;
        }
        #constrainer2 table {
            overflow-y: scroll;
        }
        #constrainer2 tbody {
            overflow-x: scroll;
            display: block;
            height: 200px;
        }
        #constrainer2 thead {
            display: table-row;
        }
        /* only styling below here */
        #constrainer, #constrainer2 {
            border: 1px solid lightgrey;
        }
        table {
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid gray;
        }
        th {
            background-color: lightgrey;
            border-width: 1px;
        }
        td {
            border-width: 1px;
        }
        tr:first-child td {
            border-top-width: 0;
        }
        tr:nth-child(even) {
            background-color: #eee;
        }
    </style>
</head>
<body>
	<h3>State Soil Data Access (SDA) Hydric Soils List</h3>
	<p>
	An SDA-populated select list is used to pick a state and SSA which enables creation of a "Hydric Soils Report" based upon those selections. The data is not static; it hits Soil Data Access Live. To reset the table hit F5 on the keyboard. Once a survey is selected and table appears, if a new survey is selected it will append to the table at the bottom. 
	<a href='#reportref'> For more information about the table, </a>
	</p>
	<a name='top'>
	
	<!-- The following "div" tag will be updated with the retrieved data
		After the first selection the "(select a state)" will disappear -->
	<select id="selectId1" onchange="ChangeSelectedState(event)">
		<option value='' style="display: none" id="remove">(select a state)</option>
	</select>
	
	<div id="selectedStateId"><p>(no state selected)</p></div>
	
	<div id="id1"></div>
		<br></br
	<b>
		<font color='red'>
			<a name='reportref'>Report Metadata:</a>
		</font>
	</b>
	<php>
		<a href='#top'>Back to top</a>
	</php>
	<ul>
	<li><b>Area_Symbol: </b>A symbol that uniquely identifies a single occurrence of a particular type of area (e.g. Dane Co., Wisconsin is WI025).</li>
	<li><b>Area_Name: </b> The name given to the specified geographic area.</li>
	<li><b>mukey: </b> A non-connotative string of characters used to uniquely identify a record in the Mapunit table.</li>
	<li><b>Mapunit_SYM: </b> The symbol used to uniquely identify the soil mapunit in the soil survey.</li>
	<li><b>Mapunit_Name: </b> Correlated name of the mapunit (recommended name or field name for surveys in progress).</li>
	<li><b>Comp_Name_phase: </b> Component name - Name assigned to a component based on its range of properties. Local Phase - Phase criterion to be used at a local level, in conjunction with "component name" to help identify a soil component.</li>
	
	<li><b>muacres: </b> The number of acres of a particular mapunit. </li>
	<li><b>Comp_RV_Pct:  </b>The percentage of the component of the mapunit.</li>
	<li><b>majcompflag: </b> Indicates whether or not a component is a major component in the mapunit.</li>
	<li><b>Comp_Acres: </b>The number of acres of a particular component in a mapunit. ((muacres*comppct_r)/100)</li>
	<li><b>Comp_Landform: </b> A word or group of words used to name a feature on the earth's surface, expressed in the plural form. Column Physical </li>
	<li><b>Hydric_Rating: </b> A yes/no field that indicates whether or not a map unit component is classified as a "hydric soil". If rated as hydric, the specific criteria met are listed in the Component Hydric Criteria table.</li>
	<li><b>Hydric_criteria: </b> Criterion code for the soil characteristic(s) and/or feature(s) that cause the map unit component to be classified as a "hydric soil." These codes are the paragraph numbers in the hydric soil criteria publication.</li>
	</ul>

	<b>
		<font color='red'>
			<a name='reportref'>Criteria:</a>
		</font>
	</b>	
	
	<ol type="1">


	<li>
		All Histels except Folistels and Histosols except Folists; or </li>
	<li>
		Map unit components in Aquic suborders, great groups, or subgroups, Albolls suborder, Historthels great group, Histoturbels great group, or Andic, Cumulic, Pachic, or Vitrandic subgroups that: 
		<ol type="a">
			<li>
				<span style="font-size: 12px;">Based on the range of characteristics for the soil series, will at least in part meet one or more Field Indicators of Hydric Soils in the United States, or</span></li>
			<li>
				<span style="font-size: 12px;">Show evidence that the soil meets the definition of a hydric soil;</span></li>
		</ol>
	</li>
	<li>
		Map unit components that are frequently ponded for long duration or very long duration during the growing season that: 
		
			<ol type="a">
			<li>
				<span style="font-size: 12px;">Based on the range of characteristics for the soil series, will at least in part meet one or more Field Indicators of Hydric Soils in the United States, or</span>
				
				
				</li>
			<li>
				<span style="font-size: 12px;">Show evidence that the soil meets the definition of a hydric soil; or</span></li>
		</ol>
		</li>
	<li>
		Map unit components that are frequently flooded for long duration or very long duration during the growing season that:
		<ol type="a">
			<li>
				<span style="font-size: 12px;">Based on the range of characteristics for the soil series, will at least in part meet one or more Field Indicators of Hydric Soils in the United States, or </span>
				
				
				</li>
			<li>
				<span style="font-size: 12px;">Show evidence that the soils meet the definition of a hydric soil.</span></li>
		</ol>
		</li>
</ol>

	<script>
		var url =  "HTTPS://sdmdataaccess.sc.egov.usda.gov/tabular/post.rest";
		var stateId = "";
		// Wait for everything to be loaded before starting the first SDA request
		$(document).ready(function(){
			// Start by retrieving a state list
			var data = {
				query: "select statename, stateid from state order by statename;",
				format: "json"
			}
			$.post(url, data, function( callbackData ) {
					loadSelect("selectId1", callbackData.Table, 1, 0, "select a state");
				}, 
				"json");
		});
		
		function loadSelect(id, table, valueColumn, labelColumn, hintOption) {
			// Add options to the specified select list. The content of the table[valueColumn]
			// defines the value of the selection, the table[labelColumn] is used for the 
			// displayed option's text.
			var iRow = 0;
			$("#" + id)[0].innerHTML = "<option value='' style='display: none' id='remove'>(" + hintOption + ")</option>";
			while (iRow < table.length) {
				var row = table[iRow];
				var optionHtml = "<option value='" + row[valueColumn] + "'>" + row[labelColumn] + "</option>";
				$("#" + id).append(optionHtml);
				iRow++;
			}
		}
		
		function ChangeSelectedState(event) {
			// Update the selected state text area and then fetch and display report 1 results
			var stateId = event.target.value;
			var notification = $("#selectedStateId");
			notification[0].innerHTML = "<p>selected stateId = " + stateId + "</p>";
			
			var query = "SELECT LEFT((areasymbol), 2) as State_Sym,  l.areasymbol as Area_Symbol, "
+"		l.areaname as Area_Name,  mu.mukey,  mu.musym as Mapunit_SYM,  mu.muname as Mapunit_Name, "
+  "case when localphase is null then compname else compname + ', ' + localphase end as Comp_Name_phase, muacres,"
+ " comppct_r/1 as Comp_RV_Pct,  majcompflag,  ((muacres*comppct_r)/100) as Comp_Acres,  "
+"SUBSTRING( (SELECT DISTINCT ( ', ' +  cogeomordesc.geomfname) FROM cogeomordesc WHERE c.cokey = cogeomordesc.cokey AND cogeomordesc.rvindicator='yes' and cogeomordesc.geomftname = 'Landform' GROUP BY cogeomordesc.geomfname FOR XML PATH('') ), 3, 1000)  as Comp_Landform, "
+" SUBSTRING( (SELECT  DISTINCT ( ', ' +  cogeomordesc.geomfname) FROM cogeomordesc WHERE c.cokey = cogeomordesc.cokey AND cogeomordesc.rvindicator='yes' and cogeomordesc.geomftname = 'Microfeature' GROUP  BY cogeomordesc.geomfname FOR XML PATH('') ), 3, 1000)  as microfeature, " 
+"hydricrating as Hydric_Rating,"
+" SUBSTRING(  (  SELECT ( ', ' + hydriccriterion) FROM cohydriccriteria WHERE c.cokey = cohydriccriteria.cokey ORDER BY hydriccriterion ASC FOR XML PATH('') ), 3, 1000) as hydric_criteria "
+"FROM legend AS l "
+"INNER JOIN mapunit AS mu ON mu.lkey = l.lkey"
+" INNER JOIN component AS c ON mu.mukey=c.mukey  AND (hydricrating like 'yes')"
+"		AND  LEFT(l.areasymbol,2) LIKE  '"  + stateId + "'"
+"	ORDER by l.areasymbol, mu.muname, mu.musym, comppct_r DESC	";
				
				
			var data = {
				query: query,
				format: "json+columnname"
			}
			
			$.post(url, data, function( callbackData ) {
				// the success callback function: when executed add content to table
					$('#id1')[0].innerHTML = "";
					var tableHtml = ' <style> body{
  background-color: #bdc3c7;
}
.table-fixed{
  width: 100%;
  background-color: #f3f3f3;
  tbody{
    height:200px;
    overflow-y:auto;
    width: 100%;
    }
  thead,tbody,tr,td,th{
    display:block;
  }
  tbody{
    td{
      float:left;
    }
  }
  thead {
    tr{
      th{
        float:left;
       background-color: #f39c12;
       border-color:#e67e22;
      }
    }
  }
}
</style><table border="1" class="table table-fixed" >';
					// for each row...
	                var iRow = 0;
                while (iRow < callbackData.Table.length) {
                                var row = callbackData.Table[iRow];
                                tableHtml += "<tr>";
                                // for each column in each row...
                                var iCol = 0;
                                while (iCol < row.length) {
                                                if (iRow == 0) {
                                                                tableHtml += "<th>" + row[iCol] + "</th>";
                                                } else {
                                                                tableHtml += "<td>" + row[iCol] + "</td>";
                                                }
                                                iCol++;
                                };
                                tableHtml += "</tr>";                                  
                                iRow++;
                };

					tableHtml += '</table>'
					$('#id1').append(tableHtml);
				}, 
				// Specify that we want the request to be sent in JSON format
				"json");			
			
				
		}
	</script>
</body>
</html>