<!DOCTYPE HTML>
<html>
<head>
 <meta http-equiv="X-UA-Compatible" content="IE=edge"> 
	<title>NRCS Hydric Soils List</title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
	<script> function demoFromHTML() {
    var pdf = new jsPDF('p', 'pt', 'letter');
    // source can be HTML-formatted string, or a reference
    // to an actual DOM element from which the text will be scraped.
    source = $('#customers')[0];

    // we support special element handlers. Register them with jQuery-style 
    // ID selector for either ID or node name. ("#iAmID", "div", "span" etc.)
    // There is no support for any other type of selectors 
    // (class, of compound) at this time.
    specialElementHandlers = {
        // element with id of "bypass" - jQuery style selector
        '#bypassme': function (element, renderer) {
            // true = "handled elsewhere, bypass text extraction"
            return true
        }
    };
    margins = {
        top: 80,
        bottom: 60,
        left: 10,
        width: 700
    };
    // all coords and widths are in jsPDF instance's declared units
    // 'inches' in this case
    pdf.fromHTML(
    source, // HTML string or DOM elem ref.
    margins.left, // x coord
    margins.top, { // y coord
        'width': margins.width, // max width of content on PDF
        'elementHandlers': specialElementHandlers
    },

    function (dispose) {
        // dispose: object with X, Y of the last line add to the PDF 
        //          this allow the insertion of new lines after html
        pdf.save('Test.pdf');
    }, margins);
}
</script>
</head>
<style type="text/css">

<style>

<style type="text/css">

<style>

<style type="text/css">
        .scrolltable {
            overflow-x: scroll;
            height: 100%;
            display: flex;
            display: -webkit-flex;
            flex-direction: column;
            -webkit-flex-direction: column;
        }
        .scrolltable > .header {
        }
        .scrolltable > .body {
            /*noinspection CssInvalidPropertyValue*/
            width: -webkit-fit-content;
            overflow-y: scroll;
            flex: 1;
            -webkit-flex: 1;
        }
        th, td {
            min-width: 25px;
        }
        /* an outside constraint to react against */
        #constrainer {
            width: 400px;
            height: 200px;
        }
        #constrainer2 {
            width: 400px;
            overflow-x: scroll;
        }
        #constrainer2 table {
            overflow-y: scroll;
        }
        #constrainer2 tbody {
            overflow-x: scroll;
            display: block;
            height: 200px;
        }
        #constrainer2 thead {
            display: table-row;
        }
        /* only styling below here */
        #constrainer, #constrainer2 {
            border: 1px solid lightgrey;
        }
        table {
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid gray;
        }
        th {
            background-color: lightgrey;
            border-width: 1px;
        }
        td {
            border-width: 1px;
        }
        tr:first-child td {
            border-top-width: 0;
        }
        tr:nth-child(even) {
            background-color: #eee;
        }
    </style>



<body>
<!--<img src="https://websoilsurvey.sc.egov.usda.gov/App/Resources/HomePage/images/WSSMasthead4.png" alt="WSS Logo" style="width:650px;height:150px;"> -->



	<h3>Soil Data Access (SDA) Hydric Soils List</h3>
	<p>
	An SDA-populated select list is used to pick a state and SSA which enables creation of a "Hydric Soils Report" based upon those selections. The data is not static; it hits Soil Data Access Live. To reset the table hit F5 on the keyboard. Once a survey is selected and table appears, if a new survey is selected it will append to the table at the bottom. 
	<a href='#reportref'> For more information about the table, </a>
	</p>
	<a name='top'>
	<!-- The following "div" tag will be updated with the retrieved data
		After the first selection the "(select a state)" will disappear -->
	<select id="selectId1" onchange="ChangeSelectedState(event)">
		<option value='' style="display: none" id="remove">(select a state)</option>
	</select>
	
	<div id="selectedStateId"><p>(no state selected)</p></div>
	
	<select id="selectId2" onchange="ChangeSelectedSSA(event)">
		<option value='' style="display: none" id="remove">(select a soil survey area)</option>
	</select>
	
	<div id="selectedSSAId"><p>(no SSA selected)</p></div>
	
	<div class="container" id="id1"></div>
	<br></br
	<b>
		<font color='red'>
			<a name='reportref'>Report Metadata:</a>
		</font>
	</b>
	<php>
		<a href='#top'>Back to top</a>
	</php>
	<ul>
	<li><b>Area_Symbol: </b>A symbol that uniquely identifies a single occurrence of a particular type of area (e.g. Dane Co., Wisconsin is WI025).</li>
	<li><b>Area_Name: </b> The name given to the specified geographic area.</li>
	<li><b>mukey: </b> A non-connotative string of characters used to uniquely identify a record in the Mapunit table.</li>
	<li><b>Mapunit_SYM: </b> The symbol used to uniquely identify the soil mapunit in the soil survey.</li>
	<li><b>Mapunit_Name: </b> Correlated name of the mapunit (recommended name or field name for surveys in progress).</li>
	<li><b>Comp_Name_phase: </b> Component name - Name assigned to a component based on its range of properties. Local Phase - Phase criterion to be used at a local level, in conjunction with "component name" to help identify a soil component.</li>
	
	<li><b>muacres: </b> The number of acres of a particular mapunit. </li>
	<li><b>Comp_RV_Pct:  </b>The percentage of the component of the mapunit.</li>
	<li><b>majcompflag: </b> Indicates whether or not a component is a major component in the mapunit.</li>
	<li><b>Comp_Acres: </b>The number of acres of a particular component in a mapunit. ((muacres*comppct_r)/100)</li>
	<li><b>Comp_Landform: </b> A word or group of words used to name a feature on the earth's surface, expressed in the plural form. Column Physical </li>
	<li><b>Hydric_Rating: </b> A yes/no field that indicates whether or not a map unit component is classified as a "hydric soil". If rated as hydric, the specific criteria met are listed in the Component Hydric Criteria table.</li>
	<li><b>Hydric_criteria: </b> Criterion code for the soil characteristic(s) and/or feature(s) that cause the map unit component to be classified as a "hydric soil." These codes are the paragraph numbers in the hydric soil criteria publication.</li>
	</ul>

	<b>
		<font color='red'>
			<a name='reportref'>Criteria:</a>
		</font>
	</b>	
	
	<ol type="1">


	<li>
		All Histels except Folistels and Histosols except Folists; or </li>
	<li>
		Map unit components in Aquic suborders, great groups, or subgroups, Albolls suborder, Historthels great group, Histoturbels great group, or Andic, Cumulic, Pachic, or Vitrandic subgroups that: 
		<ol type="a">
			<li>
				<span style="font-size: 12px;">Based on the range of characteristics for the soil series, will at least in part meet one or more Field Indicators of Hydric Soils in the United States, or</span></li>
			<li>
				<span style="font-size: 12px;">Show evidence that the soil meets the definition of a hydric soil;</span></li>
		</ol>
	</li>
	<li>
		Map unit components that are frequently ponded for long duration or very long duration during the growing season that: 
		
			<ol type="a">
			<li>
				<span style="font-size: 12px;">Based on the range of characteristics for the soil series, will at least in part meet one or more Field Indicators of Hydric Soils in the United States, or</span>
				
				
				</li>
			<li>
				<span style="font-size: 12px;">Show evidence that the soil meets the definition of a hydric soil; or</span></li>
		</ol>
		</li>
	<li>
		Map unit components that are frequently flooded for long duration or very long duration during the growing season that:
		<ol type="a">
			<li>
				<span style="font-size: 12px;">Based on the range of characteristics for the soil series, will at least in part meet one or more Field Indicators of Hydric Soils in the United States, or </span>
				
				
				</li>
			<li>
				<span style="font-size: 12px;">Show evidence that the soils meet the definition of a hydric soil.</span></li>
		</ol>
		</li>
</ol>

	<script>
		var url =  "HTTPS://sdmdataaccess.sc.egov.usda.gov/tabular/post.rest";
		var stateId = "";
		// Wait for everything to be loaded before starting the first SDA request
		$(document).ready(function(){
			// Start by retrieving a state list
			var data = {
				query: "select statename, stateid from state order by statename;",
				format: "json"
			}
			$.post(url, data, function( callbackData ) {
					loadSelect("selectId1", callbackData.Table, 1, 0, "select a state");
				}, 
				"json");
		});
		
		function loadSelect(id, table, valueColumn, labelColumn, hintOption) {
			// Add options to the specified select list. The content of the table[valueColumn]
			// defines the value of the selection, the table[labelColumn] is used for the 
			// displayed option's text.
			var iRow = 0;
			$("#" + id)[0].innerHTML = "<option value='' style='display: none' id='remove'>(" + hintOption + ")</option>";
			while (iRow < table.length) {
				var row = table[iRow];
				var optionHtml = "<option value='" + row[valueColumn] + "'>" + row[labelColumn] + "</option>";
				$("#" + id).append(optionHtml);
				iRow++;
			}
		}
		
		function ChangeSelectedState(event) {
			// Update the selected state text area and then fetch SSA names and symbols
			var stateId = event.target.value;
			var notification = $("#selectedStateId");
			notification[0].innerHTML = "<p>selected stateId = " + stateId + "</p>";
			
			query =
				"SELECT distinct c.areaname, c.areasymbol "
				+ "FROM [dbo].[sastatusmap] c, [dbo].[saspatialver] s "
				+ "WHERE s.areasymbol = c.areasymbol "
				+ "AND c.areasymbol IN ("
				+ "SELECT DISTINCT l.areasymbol "
				+ "FROM [dbo].[legend] l, [dbo].[laoverlap] o "
				+ "WHERE o.lkey = l.lkey "
				+ "AND o.areatypename = 'State or Territory' "
				+ "AND o.areasymbol = '" + stateId + "' ) "
				+ "order by c.areaname, c.areasymbol;";

			var data = {
				query: query,
				format: "json"
			}
			
			$.post(url, data, function( callbackData ) {
					loadSelect("selectId2", callbackData.Table, 1, 0, "select an SSA");
				}, 
				"json");
		}
		
		function ChangeSelectedSSA(event) {
			// Update the selected SSA text area and then fetch and display report 2 results
			var ssaId = event.target.value;
			var notification = $("#selectedSSAId");
			notification[0].innerHTML = "<p>selected SSA areasymbol = " + ssaId + "</p>";
			
		query = "SELECT LEFT((areasymbol), 2) as State_Sym,  l.areasymbol as Area_Symbol, "
+"		l.areaname as Area_Name,  mu.mukey,  mu.musym as Mapunit_SYM,  mu.muname as Mapunit_Name, "
+  "case when localphase is null then compname else compname + ', ' + localphase end as Comp_Name_phase, muacres,"
+ " comppct_r/1 as Comp_RV_Pct,  majcompflag,  CAST ((CAST( (muacres*comppct_r) AS numeric (10,1))/100) AS numeric (10,1))as Comp_Acres,  "
+"SUBSTRING( (SELECT DISTINCT ( ', ' +  cogeomordesc.geomfname) FROM cogeomordesc WHERE c.cokey = cogeomordesc.cokey AND cogeomordesc.rvindicator='yes' and cogeomordesc.geomftname = 'Landform' GROUP BY cogeomordesc.geomfname FOR XML PATH('') ), 3, 1000)  as Comp_Landform, "
+" SUBSTRING( (SELECT  DISTINCT ( ', ' +  cogeomordesc.geomfname) FROM cogeomordesc WHERE c.cokey = cogeomordesc.cokey AND cogeomordesc.rvindicator='yes' and cogeomordesc.geomftname = 'Microfeature' GROUP  BY cogeomordesc.geomfname FOR XML PATH('') ), 3, 1000)  as microfeature, " 
+"hydricrating as Hydric_Rating,"
+" SUBSTRING(  (  SELECT ( ', ' + hydriccriterion) FROM cohydriccriteria WHERE c.cokey = cohydriccriteria.cokey ORDER BY hydriccriterion ASC FOR XML PATH('') ), 3, 1000) as hydric_criteria "
+"FROM legend AS l "
+"INNER JOIN mapunit AS mu ON mu.lkey = l.lkey"
+" INNER JOIN component AS c ON mu.mukey=c.mukey  AND (hydricrating like 'yes')"
+"		AND  l.areasymbol = '"  + ssaId + "'"
+"	ORDER by l.areasymbol, mu.muname, mu.musym, comppct_r DESC	";
			
					var data = {
				query: query,
				format: "json+columnname"
			}
			
			$.post(url, data, function( callbackData ) {
				// the success callback function: when executed add content to table
					$('#id1')[0].innerHTML = "";
					var tableHtml = '<table border="1">';
					// for each row...
		                var iRow = 0;
                while (iRow < callbackData.Table.length) {
                                var row = callbackData.Table[iRow];
                                tableHtml += "<tr>";
                                // for each column in each row...
                                var iCol = 0;
                                while (iCol < row.length) {
                                                if (iRow == 0) {
                                                                tableHtml += "<th>" + row[iCol] + "</th>";
                                                } else {
                                                                tableHtml += "<td>" + row[iCol] + "</td>";
                                                }
                                                iCol++;
                                };
                                tableHtml += "</tr>";                                  
                                iRow++;
                };

					tableHtml += '</table>'
					$('#id1').append(tableHtml);
				}, 
				// Specify that we want the request to be sent in JSON format
				"json");			
			
				
		}
	</script>
	
<script>
$(function(){
	$('table').each(function() {
		if($(this).find('thead').length > 0 && $(this).find('th').length > 0) {
			// Clone <thead>
			var $w	   = $(window),
				$t	   = $(this),
				$thead = $t.find('thead').clone(),
				$col   = $t.find('thead, tbody').clone();

			// Add class, remove margins, reset width and wrap table
			$t
			.addClass('sticky-enabled')
			.css({
				margin: 0,
				width: '100%'
			}).wrap('<div class="sticky-wrap" />');

			if($t.hasClass('overflow-y')) $t.removeClass('overflow-y').parent().addClass('overflow-y');

			// Create new sticky table head (basic)
			$t.after('<table class="sticky-thead" />');

			// If <tbody> contains <th>, then we create sticky column and intersect (advanced)
			if($t.find('tbody th').length > 0) {
				$t.after('<table class="sticky-col" /><table class="sticky-intersect" />');
			}

			// Create shorthand for things
			var $stickyHead  = $(this).siblings('.sticky-thead'),
				$stickyCol   = $(this).siblings('.sticky-col'),
				$stickyInsct = $(this).siblings('.sticky-intersect'),
				$stickyWrap  = $(this).parent('.sticky-wrap');

			$stickyHead.append($thead);

			$stickyCol
			.append($col)
				.find('thead th:gt(0)').remove()
				.end()
				.find('tbody td').remove();

			$stickyInsct.html('<thead><tr><th>'+$t.find('thead th:first-child').html()+'</th></tr></thead>');
			
			// Set widths
			var setWidths = function () {
					$t
					.find('thead th').each(function (i) {
						$stickyHead.find('th').eq(i).width($(this).width());
					})
					.end()
					.find('tr').each(function (i) {
						$stickyCol.find('tr').eq(i).height($(this).height());
					});

					// Set width of sticky table head
					$stickyHead.width($t.width());

					// Set width of sticky table col
					$stickyCol.find('th').add($stickyInsct.find('th')).width($t.find('thead th').width())
				},
				repositionStickyHead = function () {
					// Return value of calculated allowance
					var allowance = calcAllowance();
				
					// Check if wrapper parent is overflowing along the y-axis
					if($t.height() > $stickyWrap.height()) {
						// If it is overflowing (advanced layout)
						// Position sticky header based on wrapper scrollTop()
						if($stickyWrap.scrollTop() > 0) {
							// When top of wrapping parent is out of view
							$stickyHead.add($stickyInsct).css({
								opacity: 1,
								top: $stickyWrap.scrollTop()
							});
						} else {
							// When top of wrapping parent is in view
							$stickyHead.add($stickyInsct).css({
								opacity: 0,
								top: 0
							});
						}
					} else {
						// If it is not overflowing (basic layout)
						// Position sticky header based on viewport scrollTop
						if($w.scrollTop() > $t.offset().top && $w.scrollTop() < $t.offset().top + $t.outerHeight() - allowance) {
							// When top of viewport is in the table itself
							$stickyHead.add($stickyInsct).css({
								opacity: 1,
								top: $w.scrollTop() - $t.offset().top
							});
						} else {
							// When top of viewport is above or below table
							$stickyHead.add($stickyInsct).css({
								opacity: 0,
								top: 0
							});
						}
					}
				},
				repositionStickyCol = function () {
					if($stickyWrap.scrollLeft() > 0) {
						// When left of wrapping parent is out of view
						$stickyCol.add($stickyInsct).css({
							opacity: 1,
							left: $stickyWrap.scrollLeft()
						});
					} else {
						// When left of wrapping parent is in view
						$stickyCol
						.css({ opacity: 0 })
						.add($stickyInsct).css({ left: 0 });
					}
				},
				calcAllowance = function () {
					var a = 0;
					// Calculate allowance
					$t.find('tbody tr:lt(3)').each(function () {
						a += $(this).height();
					});
					
					// Set fail safe limit (last three row might be too tall)
					// Set arbitrary limit at 0.25 of viewport height, or you can use an arbitrary pixel value
					if(a > $w.height()*0.25) {
						a = $w.height()*0.25;
					}
					
					// Add the height of sticky header
					a += $stickyHead.height();
					return a;
				};

			setWidths();

			$t.parent('.sticky-wrap').scroll($.throttle(250, function() {
				repositionStickyHead();
				repositionStickyCol();
			}));

			$w
			.load(setWidths)
			.resize($.debounce(250, function () {
				setWidths();
				repositionStickyHead();
				repositionStickyCol();
			}))
			.scroll($.throttle(250, repositionStickyHead));
		}
	});
});
</script>
</body>
</html>