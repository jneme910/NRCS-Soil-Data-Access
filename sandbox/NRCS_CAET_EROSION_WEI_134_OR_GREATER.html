
<!DOCTYPE HTML>
<html>
<head>
 <meta http-equiv="X-UA-Compatible" content="IE=edge"> 
	<title>NRCS Wind Erodibility Index Greater than or Equal to 134</title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
</head>
<style type="text/css">

<style>

<style type="text/css">

<style>

<style type="text/css">
        .scrolltable {
            overflow-x: scroll;
            height: 100%;
            display: flex;
            display: -webkit-flex;
            flex-direction: column;
            -webkit-flex-direction: column;
        }
        .scrolltable > .header {
        }
        .scrolltable > .body {
            /*noinspection CssInvalidPropertyValue*/
            width: -webkit-fit-content;
            overflow-y: scroll;
            flex: 1;
            -webkit-flex: 1;
        }
        th, td {
            min-width: 25px;
        }
        /* an outside constraint to react against */
        #constrainer {
            width: 400px;
            height: 200px;
        }
        #constrainer2 {
            width: 400px;
            overflow-x: scroll;
        }
        #constrainer2 table {
            overflow-y: scroll;
        }
        #constrainer2 tbody {
            overflow-x: scroll;
            display: block;
            height: 200px;
        }
        #constrainer2 thead {
            display: table-row;
        }
        /* only styling below here */
        #constrainer, #constrainer2 {
            border: 1px solid lightgrey;
        }
        table {
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid gray;
        }
        th {
            background-color: lightgrey;
            border-width: 1px;
        }
        td {
            border-width: 1px;
        }
        tr:first-child td {
            border-top-width: 0;
        }
        tr:nth-child(even) {
            background-color: #eee;
        }
    </style>



<body>
<!--<img src="https://websoilsurvey.sc.egov.usda.gov/App/Resources/HomePage/images/WSSMasthead4.png" alt="WSS Logo" style="width:650px;height:150px;"> -->



	<h3>Soil Data Access (SDA) Wind Erodibility Index (WEI) Soils Report</h3>
	<p>
	An SDA-populated select list is used to pick a state and SSA which enables creation of a "Wind Erodibility Index (WEI) Soils Report" based upon those selections where WEI is equal or greater than 134. The data is not static; it hits Soil Data Access Live. To reset the table hit F5 on the keyboard. Once a survey is selected and table appears, if a new survey is selected it will append to the table at the bottom. 
	<a href='#reportref'> For more information about the table, </a>
	</p>
	<a name='top'>
	<!-- The following "div" tag will be updated with the retrieved data
		After the first selection the "(select a state)" will disappear -->
	<select id="selectId1" onchange="ChangeSelectedState(event)">
		<option value='' style="display: none" id="remove">(select a state)</option>
	</select>
	
	<div id="selectedStateId"><p>(no state selected)</p></div>
	
	<select id="selectId2" onchange="ChangeSelectedSSA(event)">
		<option value='' style="display: none" id="remove">(select a soil survey area)</option>
	</select>
	
	<div id="selectedSSAId"><p>(no SSA selected)</p></div>
	
	<div class="container" id="id1"></div>
	<br></br
	<b><h3>
		<font color='red'>
			<a name='reportref'>Report Metadata:</h3></a>
		</font>
	</b>
	<php>
		<a href='#top'>Back to top</a>
	</php>
	<ul>
	<li><b>areasymbol: </b>A symbol that uniquely identifies a single occurrence of a particular type of area (e.g. Dane Co., Wisconsin is WI025).</li>
	<li><b>areaname: </b> The name given to the specified geographic area.</li>
	<li><b>mukey: </b> A non-connotative string of characters used to uniquely identify a record in the Mapunit table.</li>

	<li><b>nuname: </b> Correlated name of the mapunit (recommended name or field name for surveys in progress).</li>
	<li><b>musym: </b> The symbol used to uniquely identify the soil mapunit in the soil survey.</li>
	<li><b>dom_cond_wei: </b> The dominant component rating of the map unit for Wind Erodibility Index, expressed as the dominant rating class for the map unit, based on composition percentage of each map unit component..</li>
	
	<li><b>dom_cond_WEI_Comp_Sum_Pct: </b> The sum component percent based on the dominant condition for WEI. </li>
	
	</ul>
	<font color='red'>
	<h3>
	<a name="77"></a> Wind Erodibility Group and Index</h3></font>
<ol type="1">
	<li>
		Definition.&mdash;A wind erodibility group (WEG) is a grouping of soils that have similar properties affecting their resistance to soil blowing in cultivated areas. The groups indicate the susceptibility to blowing. The wind erodibility index (I), used in the wind erosion equation, is assigned using the wind erodibility groups.<br />
		&nbsp;</li>
	<li>
		Significance.&mdash;There is a close correlation between soil blowing and the size and durability of surface clodiness, fragments, organic matter, and the calcareous reaction. The soil properties that are most important with respect to soil blowing are listed below. Soil moisture and the presence of frozen soil also influence soil blowing.
		<ol type="a">
			<li>
				<span style="font-size: 12px;">Soil texture class</span></li>
			<li>
				<span style="font-size: 12px;">Organic matter content</span></li>
			<li>
				<span style="font-size: 12px;">Carbonates in the fine-earth fraction as determined by effervescence class</span></li>
			<li>
				<span style="font-size: 12px;">Rock and pararock fragment content</span></li>
			<li>
				<span style="font-size: 12px;">Mineralogy</span><br />
				&nbsp;</li>
		</ol>
	</li>
	<li>
		Estimates.&mdash; Soils are placed into wind erodibility groups on the basis of the properties of the soil surface layer. NSSH Subpart B, Exhibits, Section 618.95 lists the wind erodibility index assigned to the wind erodibility groups. The wind erodibility index values are assigned because the dry soil aggregates are very use-dependent on crop management factors.<br />
		&nbsp;</li>
	<li>
		Entries.&mdash;Enter the wind erodibility group and wind erodibility index values for surface layers only. The range of valid entries for wind erodibility group data is 1, 2, 3, 4, 4L, 5, 6, 7, and 8. The lowest valid entry for wind erodibility index data is 0, and the highest is 310. The index values should correspond exactly to their wind erodibility group.</li>
</ol>


	<script>
		var url =  "HTTPS://sdmdataaccess.sc.egov.usda.gov/tabular/post.rest";
		var stateId = "";
		// Wait for everything to be loaded before starting the first SDA request
		$(document).ready(function(){
			// Start by retrieving a state list
			var data = {
				query: "select statename, stateid from state order by statename;",
				format: "json"
			}
			$.post(url, data, function( callbackData ) {
					loadSelect("selectId1", callbackData.Table, 1, 0, "select a state");
				}, 
				"json");
		});
		
		function loadSelect(id, table, valueColumn, labelColumn, hintOption) {
			// Add options to the specified select list. The content of the table[valueColumn]
			// defines the value of the selection, the table[labelColumn] is used for the 
			// displayed option's text.
			var iRow = 0;
			$("#" + id)[0].innerHTML = "<option value='' style='display: none' id='remove'>(" + hintOption + ")</option>";
			while (iRow < table.length) {
				var row = table[iRow];
				var optionHtml = "<option value='" + row[valueColumn] + "'>" + row[labelColumn] + "</option>";
				$("#" + id).append(optionHtml);
				iRow++;
			}
		}
		
		function ChangeSelectedState(event) {
			// Update the selected state text area and then fetch SSA names and symbols
			var stateId = event.target.value;
			var notification = $("#selectedStateId");
			notification[0].innerHTML = "<p>selected stateId = " + stateId + "</p>";
			
			query =
				"SELECT distinct c.areaname, c.areasymbol "
				+ "FROM [dbo].[sastatusmap] c, [dbo].[saspatialver] s "
				+ "WHERE s.areasymbol = c.areasymbol "
				+ "AND c.areasymbol IN ("
				+ "SELECT DISTINCT l.areasymbol "
				+ "FROM [dbo].[legend] l, [dbo].[laoverlap] o "
				+ "WHERE o.lkey = l.lkey "
				+ "AND o.areatypename = 'State or Territory' "
				+ "AND o.areasymbol = '" + stateId + "' ) "
				+ "order by c.areaname, c.areasymbol;";

			var data = {
				query: query,
				format: "json"
			}
			
			$.post(url, data, function( callbackData ) {
					loadSelect("selectId2", callbackData.Table, 1, 0, "select an SSA");
				}, 
				"json");
		}
		
		function ChangeSelectedSSA(event) {
			// Update the selected SSA text area and then fetch and display report 2 results
			var ssaId = event.target.value;
			var notification = $("#selectedSSAId");
			notification[0].innerHTML = "<p>selected SSA areasymbol = " + ssaId + "</p>";
			
		query = "SELECT  areasymbol, musym, muname, mu.mukey/1  AS MUKEY,  (SELECT TOP 1 wei FROM mapunit INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = mu.mukey GROUP BY wei, comppct_r ORDER BY SUM(comppct_r) over(partition by wei) DESC) AS  dom_cond_wei, (SELECT TOP 1 SUM(comppct_r) over(partition by wei) FROM mapunit INNER JOIN component ON component.mukey=mapunit.mukey AND mapunit.mukey = mu.mukey GROUP BY wei, comppct_r ORDER BY SUM(comppct_r) over(partition by wei) DESC) AS  dom_cond_WEI_Comp_Sum_Pct INTO #WEI_TEMP FROM legend  AS l "
	+	"INNER JOIN  mapunit AS mu ON mu.lkey = l.lkey AND  l.areasymbol LIKE '" + ssaId + "'"
	+	"GROUP BY areasymbol, musym, muname, mu.mukey ORDER BY areasymbol, musym, muname, mu.mukey   SELECT areasymbol, musym, muname,  MUKEY, dom_cond_wei, dom_cond_WEI_Comp_Sum_Pct FROM #WEI_TEMP WHERE dom_cond_wei >=134 DROP TABLE #WEI_TEMP "
;
				
			var data = {
				query: query,
				format: "json+columnname"
			}
			
			$.post(url, data, function( callbackData ) {
					drawTable("id1", callbackData.Table);;
				}, 
				"json");			
		}
		
		function drawTable(id, table) {
			var tableHtml = '<table border="1">';
			// for each row...
			var iRow = 0;
			while (iRow < table.length) {
				var row = table[iRow];
				tableHtml += "<tr>";
				// for each column in each row...
				var iCol = 0;
				while (iCol < row.length) {
					tableHtml += "<td>" + row[iCol] + "</td>";
					iCol++;
				};
				tableHtml += "</tr>";				                                                                                   
				iRow++;
			};
			tableHtml += '</table>'
			$("#" + id).append(tableHtml);		
		}
	</script>
	
<script>
$(function(){
	$('table').each(function() {
		if($(this).find('thead').length > 0 && $(this).find('th').length > 0) {
			// Clone <thead>
			var $w	   = $(window),
				$t	   = $(this),
				$thead = $t.find('thead').clone(),
				$col   = $t.find('thead, tbody').clone();

			// Add class, remove margins, reset width and wrap table
			$t
			.addClass('sticky-enabled')
			.css({
				margin: 0,
				width: '100%'
			}).wrap('<div class="sticky-wrap" />');

			if($t.hasClass('overflow-y')) $t.removeClass('overflow-y').parent().addClass('overflow-y');

			// Create new sticky table head (basic)
			$t.after('<table class="sticky-thead" />');

			// If <tbody> contains <th>, then we create sticky column and intersect (advanced)
			if($t.find('tbody th').length > 0) {
				$t.after('<table class="sticky-col" /><table class="sticky-intersect" />');
			}

			// Create shorthand for things
			var $stickyHead  = $(this).siblings('.sticky-thead'),
				$stickyCol   = $(this).siblings('.sticky-col'),
				$stickyInsct = $(this).siblings('.sticky-intersect'),
				$stickyWrap  = $(this).parent('.sticky-wrap');

			$stickyHead.append($thead);

			$stickyCol
			.append($col)
				.find('thead th:gt(0)').remove()
				.end()
				.find('tbody td').remove();

			$stickyInsct.html('<thead><tr><th>'+$t.find('thead th:first-child').html()+'</th></tr></thead>');
			
			// Set widths
			var setWidths = function () {
					$t
					.find('thead th').each(function (i) {
						$stickyHead.find('th').eq(i).width($(this).width());
					})
					.end()
					.find('tr').each(function (i) {
						$stickyCol.find('tr').eq(i).height($(this).height());
					});

					// Set width of sticky table head
					$stickyHead.width($t.width());

					// Set width of sticky table col
					$stickyCol.find('th').add($stickyInsct.find('th')).width($t.find('thead th').width())
				},
				repositionStickyHead = function () {
					// Return value of calculated allowance
					var allowance = calcAllowance();
				
					// Check if wrapper parent is overflowing along the y-axis
					if($t.height() > $stickyWrap.height()) {
						// If it is overflowing (advanced layout)
						// Position sticky header based on wrapper scrollTop()
						if($stickyWrap.scrollTop() > 0) {
							// When top of wrapping parent is out of view
							$stickyHead.add($stickyInsct).css({
								opacity: 1,
								top: $stickyWrap.scrollTop()
							});
						} else {
							// When top of wrapping parent is in view
							$stickyHead.add($stickyInsct).css({
								opacity: 0,
								top: 0
							});
						}
					} else {
						// If it is not overflowing (basic layout)
						// Position sticky header based on viewport scrollTop
						if($w.scrollTop() > $t.offset().top && $w.scrollTop() < $t.offset().top + $t.outerHeight() - allowance) {
							// When top of viewport is in the table itself
							$stickyHead.add($stickyInsct).css({
								opacity: 1,
								top: $w.scrollTop() - $t.offset().top
							});
						} else {
							// When top of viewport is above or below table
							$stickyHead.add($stickyInsct).css({
								opacity: 0,
								top: 0
							});
						}
					}
				},
				repositionStickyCol = function () {
					if($stickyWrap.scrollLeft() > 0) {
						// When left of wrapping parent is out of view
						$stickyCol.add($stickyInsct).css({
							opacity: 1,
							left: $stickyWrap.scrollLeft()
						});
					} else {
						// When left of wrapping parent is in view
						$stickyCol
						.css({ opacity: 0 })
						.add($stickyInsct).css({ left: 0 });
					}
				},
				calcAllowance = function () {
					var a = 0;
					// Calculate allowance
					$t.find('tbody tr:lt(3)').each(function () {
						a += $(this).height();
					});
					
					// Set fail safe limit (last three row might be too tall)
					// Set arbitrary limit at 0.25 of viewport height, or you can use an arbitrary pixel value
					if(a > $w.height()*0.25) {
						a = $w.height()*0.25;
					}
					
					// Add the height of sticky header
					a += $stickyHead.height();
					return a;
				};

			setWidths();

			$t.parent('.sticky-wrap').scroll($.throttle(250, function() {
				repositionStickyHead();
				repositionStickyCol();
			}));

			$w
			.load(setWidths)
			.resize($.debounce(250, function () {
				setWidths();
				repositionStickyHead();
				repositionStickyCol();
			}))
			.scroll($.throttle(250, repositionStickyHead));
		}
	});
});
</script>
</body>
</html>