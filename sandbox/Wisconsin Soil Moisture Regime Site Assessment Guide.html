
<!DOCTYPE HTML>
<html>
<head>
 <meta http-equiv="X-UA-Compatible" content="IE=edge"> 
	<title>Wisconsin Soil Moisture Regime Site Assessment Guide</title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
	<style type="text/css">
        .scrolltable {
            overflow-x: scroll;
            height: 100%;
            display: flex;
            display: -webkit-flex;
            flex-direction: column;
            -webkit-flex-direction: column;
        }
        .scrolltable > .header {
        }
        .scrolltable > .body {
            /*noinspection CssInvalidPropertyValue*/
            width: -webkit-fit-content;
            overflow-y: scroll;
            flex: 1;
            -webkit-flex: 1;
        }
        th, td {
            min-width: 25px;
        }
        /* an outside constraint to react against */
        #constrainer {
            width: 400px;
            height: 200px;
        }
        #constrainer2 {
            width: 400px;
            overflow-x: scroll;
        }
        #constrainer2 table {
            overflow-y: scroll;
        }
        #constrainer2 tbody {
            overflow-x: scroll;
            display: block;
            height: 200px;
        }
        #constrainer2 thead {
            display: table-row;
        }
        /* only styling below here */
        #constrainer, #constrainer2 {
            border: 1px solid lightgrey;
        }
        table {
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid gray;
        }
        th {
            background-color: lightgrey;
            border-width: 1px;
        }
        td {
            border-width: 1px;
        }
        tr:first-child td {
            border-top-width: 0;
        }
        tr:nth-child(even) {
            background-color: #d9e0f9;
        }
    </style>
</head>
<body>
<hr style="border: none; border-bottom: 4px solid grey;">
<font color="blue">
		<h2>Soil Moisture Regime Site Assessment Guide</h2>
		</font>
		<hr style="border: none; border-bottom: 4px solid grey;">
	<p>
	This dataset is dynamically loaded from our live database. Once a survey is selected a table appears.  The information in this report is primarily used to select species for seeding mixes that will do well based on the soil moisture regimes in the project area.  Information for vegetative species selection can be found in NRCS technical notes and standards located in the Field Office Technical Guide (FOTG).  Common NRCS standards that use soil moisture regime data include Critical Area Planting (342), Conservation Cover (327), and Forage & Biomass Planting (512).
	<a href='#reportref'> For more information about the table, </a>
	</p>
	<a name='top'>
	
	<!-- The following "div" tag will be updated with the retrieved data
		After the first selection the "(select a state)" will disappear -->
	<select id="selectId1" onchange="ChangeSelectedState(event)">
		<option value='' style="display: none" id="remove">(select a Soil Survey Area)</option>
	</select>
	
	<div id="selectedStateId"><p>(no Soil Survey Area selected)</p></div>
	
	<div id="id1"></div>
		<br></br
	<b>
		<font color='red'>
			<a name='reportref'>Report Metadata:</a>
		</font>
	</b>
	<php>
		<a href='#top'>Back to top</a>
	</php>
	<ul>
<li><b>mukey:</b> A non-connotative string of characters used to uniquely identify a record in the Mapunit table. </li>
<li><b>cokey: </b> A non-connotative string of characters used to uniquely identify a record in the Mapunit table and component table.</li>
<li><b>Mapunit Symbol: </b> The symbol used to uniquely identify the soil mapunit in the soil survey. The Map Unit Symbols are just symbols displayed on a map and link to data. A map unit symbol is used to uniquely identify the soil mapunit in the soil survey and not ids. They are a way to link the spatial data to tabular data and does not necessary have any meaning except to provide someone a way to look up the tabular data. </li>
<li><b>Mapunit Name:  </b> Correlated name of the mapunit (recommended name or field name for surveys in progress).</li>
<li><b>compname: </b>Name assigned to a component based on its range of properties. </li>
<li><b>Component Percent: </b>	The percentage of the component of the mapunit. (RV) </li>


<li><b>Depth to Wetness (cm): </b>Depth at which the component has a saturated layer. In field is blank, then no observed saturated layer is observed</li>
<li><b>Available Water Storage (100 cm)</b>	Total Available Water, reported in cm, to a depth of 100cm, or to the depth of a root restrictive layer if the restrictive layer is shallower
than 100cm</li>
<li><b>Flooding(frequency + duration)	</b>The flooding field will be 0, 1 or 2. One point is given for meeting the frequency criteria and one point for meeting the duration. A
component with a frequency of Frequent or Very Frequent in any month will be given 1 point. A component with a duration of Long or
Very Long will be given 1 point. The values for frequency and duration are summed and reported in this field.</li>
<li><b>Soil Moisture Site Condition</b>	Soils with a WET soil moisture condition are: Histosols, soils with a saturated zone <= 30cm, or soils that are frequently or very
frequently flooded for long or very long durations. Soils with a WET-MESIC soil moisture condition do not meet the definition of WET
AND are in the suborder of aquic and have an AWC to 100cm of >= 15.24cm OR have a saturated layer deeper than 30cm but not deeper
than 91cm. Soils with a soil moisture condition of MESIC do not meet the definition of WET or WET-MESIC AND have an AWC to 100cm
>= to 15.24 cm OR have a suborder of aquic and an AWC to 100cm < 15.24 cm OR have a saturated layer between 30cm and 91cm AND an
AWC to 100cm < 15.24 cm. . Soils with a DRY-MESIC soil moisture condition do not meet the criteria of WET, WET-MESIC or MESIC and
have an AWC to 100cm between 7.62cm to 15.24 cm. Soils with a DRY soil moisture condition do not meet the criteria of WET, WETMESIC
,MESIC or DRY-MESIC and have an AWC to 100cm less than 7.62cm.</li>


	</ul>



	<script>
		var url =  "HTTPS://sdmdataaccess.sc.egov.usda.gov/tabular/post.rest";
		var stateId = "";
		// Wait for everything to be loaded before starting the first SDA request
		$(document).ready(function(){
			// Start by retrieving a state list
			var data = {
				query: "		SELECT distinct c.areaname, c.areasymbol, c.areasymbol  AS stateid 				FROM [dbo].[sastatusmap] c, [dbo].[saspatialver] s 				WHERE s.areasymbol = c.areasymbol 				AND c.areasymbol IN ( 				SELECT DISTINCT l.areasymbol 				FROM [dbo].[legend] l, [dbo].[laoverlap] o 				WHERE o.lkey = l.lkey 				AND o.areatypename = 'State or Territory' 				AND o.areasymbol = 'WI' ) 				order by c.areaname, c.areasymbol;",
				
				
				format: "json"
			}
			$.post(url, data, function( callbackData ) {
					loadSelect("selectId1", callbackData.Table, 1, 0, "select a Soil Survey Area");
				}, 
				"json");
		});
		
		function loadSelect(id, table, valueColumn, labelColumn, hintOption) {
			// Add options to the specified select list. The content of the table[valueColumn]
			// defines the value of the selection, the table[labelColumn] is used for the 
			// displayed option's text.
			var iRow = 0;
			$("#" + id)[0].innerHTML = "<option value='' style='display: none' id='remove'>(" + hintOption + ")</option>";
			while (iRow < table.length) {
				var row = table[iRow];
				var optionHtml = "<option value='" + row[valueColumn] + "'>" + row[labelColumn] + "</option>";
				$("#" + id).append(optionHtml);
				iRow++;
			}
		}
		
		function ChangeSelectedState(event) {
			// Update the selected state text area and then fetch and display report 1 results
			var stateId = event.target.value;
			var notification = $("#selectedStateId");
			notification[0].innerHTML = "<p>selected stateId = " + stateId + "</p>";
			
			var 	query = "SELECT areasymbol, areaname, mapunit.mukey, mapunit.musym, nationalmusym, mapunit.muname, mukind, muacres, compname, comppct_r, component.cokey, taxorder, taxsuborder"
+"	INTO #main "
			+"	FROM legend "
+"	INNER JOIN mapunit on legend.lkey=mapunit.lkey "
+"	INNER JOIN component ON component.mukey=mapunit.mukey AND majcompflag = 'Yes' "
+"		AND  legend.areasymbol = '"  + stateId + "'"
+"	ORDER BY mapunit.muname ASC, mapunit.mukey,comppct_r DESC, compname "

+"	SELECT muname, cwet.compname, #main.mukey, cwet.cokey, cwet.comppct_r,  (SELECT  TOP 1 (soimoistdept_r) "
+"	FROM component AS cwet2 "
+"	INNER JOIN comonth ON comonth.cokey=cwet2.cokey AND cwet2.cokey=cwet.cokey "
+"	INNER JOIN cosoilmoist on cosoilmoist.comonthkey=comonth.comonthkey AND soimoiststat = 'wet' ORDER BY soimoistdept_r ASC) AS MIN_Wet, "
+"	(SELECT top 1 flodfreqcl from comonth, MetadataDomainMaster dm, MetadataDomainDetail dd where comonth.cokey = cwet.cokey and flodfreqcl = ChoiceLabel and DomainName = 'flooding_frequency_class' and "
+"	dm.DomainID = dd.DomainID order by choicesequence desc) as annflodfreq, "
+"	(SELECT top 1 floddurcl from comonth, MetadataDomainMaster dm, MetadataDomainDetail dd where comonth.cokey = cwet.cokey and floddurcl = ChoiceLabel and DomainName = 'flooding_duration_class' and "
+"	dm.DomainID = dd.DomainID order by choicesequence desc) as annfloddur "
+"	INTO #wet "
+"	FROM #main "
+"	INNER JOIN component AS cwet ON cwet.mukey=#main.mukey "
+"	GROUP BY muname, #main.mukey, cwet.comppct_r, cwet.compname, cwet.cokey "
+"	ORDER BY muname, #main.mukey, cwet.comppct_r DESC, cwet.compname, cwet.cokey "

+"	SELECT  "
+"	LEFT((areasymbol), 2) AS state,  "
+"	mu.muname,  "
+"	 l.areasymbol, "
+"	 l.areaname, "
+"	(SELECT SUM (DISTINCT comppct_r) FROM mapunit  AS mui3  INNER JOIN component AS cint3 ON cint3.mukey=mui3.mukey INNER JOIN chorizon AS chint3 ON chint3.cokey=cint3.cokey AND cint3.cokey = c.cokey GROUP BY chint3.cokey) AS sum_comp,  "
+"	 mu.mukey,  "
+"	 mu.musym,  "
+"	 c.majcompflag,  "
+"	 c.comppct_r,  "
+"	 c.compname,  "
+"	 compkind,  "
+"	 localphase,  "
+"	 slope_l,  "
+"	slope_r,  "
+"	 slope_h,  "
+"	(SELECT CAST(MIN(resdept_r) AS INTEGER) FROM component LEFT OUTER JOIN corestrictions ON component.cokey = corestrictions.cokey WHERE component.cokey = c.cokey AND reskind  IS NOT NULL) AS restrictiondepth,  "
+"	(SELECT CASE WHEN MIN (resdept_r) IS NULL THEN 200 ELSE CAST (MIN (resdept_r) AS INT) END FROM component LEFT OUTER JOIN corestrictions ON component.cokey = corestrictions.cokey WHERE component.cokey = c.cokey AND reskind IS NOT NULL) AS restrictiodepth,  "
+"	(SELECT TOP 1  reskind  FROM component LEFT OUTER JOIN corestrictions ON component.cokey = corestrictions.cokey WHERE component.cokey = c.cokey AND corestrictions.reskind IN ('bedrock, lithic', 'duripan', 'bedrock, densic', 'bedrock, paralithic', 'fragipan', 'natric', 'ortstein', 'permafrost', 'petrocalcic', 'petrogypsic')  "
+"	AND reskind IS NOT NULL ORDER BY resdept_r) AS toprestriction, c.cokey,  "
+"	 hzname,  "
+"	 hzdept_r,  "
+"	 hzdepb_r,  "
+"	 CASE WHEN (hzdepb_r-hzdept_r) IS NULL THEN 0 ELSE CAST((hzdepb_r-hzdept_r) AS INT) END AS thickness,   " 
+"	  awc_r,  "
+"	  aws025wta,  "
+"	  aws050wta,  "
+"	  aws0100wta,  "
+"	  brockdepmin,  "
+"	  texture,  "
+"	  ch.chkey  "
+"	INTO #acpf  "
+"	FROM legend  AS l  "
+"	INNER JOIN mapunit AS mu ON mu.lkey = l.lkey  "
+"		AND  l.areasymbol = '"  + stateId + "'"
+"	INNER JOIN muaggatt mt on mu.mukey=mt.mukey  "
+"	INNER JOIN component c ON c.mukey = mu.mukey  "
+"	INNER JOIN chorizon ch ON ch.cokey = c.cokey and CASE WHEN hzdept_r IS NULL THEN 2  "
+"	WHEN awc_r IS NULL THEN 2  "
+"	WHEN awc_r = 0 THEN 2 ELSE 1 END = 1  "
+"	INNER JOIN chtexturegrp ct ON ch.chkey=ct.chkey and ct.rvindicator = 'yes'  "
+"	ORDER by l.areasymbol, mu.musym, hzdept_r   "

+"	SELECT mukey, cokey,  SUM (DISTINCT sum_comp) AS sum_comp2 "
+"	INTO #muacpf "
+"	FROM #acpf AS acpf2 "
+"	WHERE acpf2.cokey=cokey "
+"	GROUP BY mukey, cokey " 

+"	SELECT mukey, cokey, sum_comp2,  SUM (sum_comp2) over(partition by #muacpf.mukey ) AS sum_comp3 "
+"	INTO #muacpf2  "
+"	FROM #muacpf  "
+"	GROUP BY mukey, cokey, sum_comp2 "


+"	SELECT mukey, cokey,  CASE WHEN sum_comp2 = sum_comp3 THEN 1 "
+"	ELSE CAST (CAST (sum_comp2 AS  decimal (5,2)) / CAST (sum_comp3 AS decimal (5,2)) AS decimal (5,2)) END AS WEIGHTED_COMP_PCT "
+"	INTO #muacpf3 "
+"	FROM #muacpf2 "

+"	SELECT muname, compname, cokey, MIN(hzdept_r) AS min_t  "
+"	INTO #hortopdepth "
+"	FROM #acpf "
+"	WHERE texture NOT LIKE '%PM%' and texture NOT LIKE '%DOM' and texture NOT LIKE '%MPT%' AND texture NOT LIKE '%MUCK' AND texture NOT LIKE '%PEAT%' "
+"	GROUP BY muname, compname, cokey "


+"	SELECT #hortopdepth.cokey,"
+"	hzname, "
+"	hzdept_r,"
+"	hzdepb_r, "
+"	thickness, "
+"	texture AS texture_surf, "
+"	awc_r AS awc_surf, "
+"	chkey "
+"	INTO #acpf2 "
+"	FROM #hortopdepth "
+"	INNER JOIN #acpf on #hortopdepth.cokey=#acpf.cokey AND #hortopdepth.min_t = #acpf.hzdept_r "
+"	ORDER BY #hortopdepth.cokey, hzname "

+"	SELECT "
+"	muname, "
+"	mukey, "
+"	cokey, "
+"	hzname, "
+"	restrictiodepth, "
+"	hzdept_r, "
+"	hzdepb_r, "
+"	CASE WHEN (hzdepb_r-hzdept_r) IS NULL THEN 0 ELSE CAST ((hzdepb_r-hzdept_r) AS INT) END AS thickness, "
+"	texture, "
+"	CASE when awc_r IS NULL THEN 0 ELSE awc_r END AS awc_r, "
+"	chkey "
+"	INTO #acpfhzn "
+"	FROM #acpf "

+"	SELECT "
+"	CASE  WHEN hzdepb_r <= 100 THEN hzdepb_r WHEN hzdepb_r > 100 and hzdept_r < 100 THEN 100 ELSE 0 END AS InRangeBot, "
+"	CASE  WHEN hzdept_r < 100 then hzdept_r ELSE 0 END AS InRangeTop, "
+"	CASE  WHEN hzdepb_r <= 20  THEN hzdepb_r WHEN hzdepb_r > 20  and hzdept_r < 20 THEN 20  ELSE 0 END AS InRangeBot_0_20, "
+"	CASE  WHEN hzdept_r < 20 then hzdept_r ELSE 0 END AS InRangeTop_0_20, "
+"	CASE  WHEN hzdepb_r <= 50  THEN hzdepb_r WHEN hzdepb_r > 50  and hzdept_r < 50 THEN 50  ELSE 20 END AS InRangeBot_20_50, "
+"	CASE  WHEN hzdept_r < 50 then hzdept_r ELSE 20 END AS InRangeTop_20_50, "
+"	CASE  WHEN hzdepb_r <= 100  THEN hzdepb_r WHEN hzdepb_r > 100  and hzdept_r < 100 THEN 100  ELSE 50 END AS InRangeBot_50_100, "
+"	CASE  WHEN hzdept_r < 100 then hzdept_r ELSE 50 END AS InRangeTop_50_100,  "
+"	awc_r, cokey, mukey "
+"	INTO #aws "
+"	FROM #acpf "
+"	ORDER BY cokey "

+"	SELECT mukey, cokey, "
+"	SUM((InRangeBot - InRangeTop)*awc_r) AS aws100, "
+"	SUM((InRangeBot_0_20 - InRangeTop_0_20)*awc_r) AS aws_0_20, "
+"	SUM((InRangeBot_20_50 - InRangeTop_20_50)*awc_r) AS aws_20_50, "
+"	SUM((InRangeBot_50_100 - InRangeTop_50_100)*awc_r) AS aws_50_100 "
+"	INTO #aws100 "
+"	FROM #aws  "
+"	GROUP BY  mukey, cokey "

+"	SELECT mukey, cokey, chkey, "
+"	 thickness, "
+"	 restrictiodepth,"
+"	(awc_r*thickness) as th_awc_r "
+"	INTO #acpf3 "
+"	FROM #acpfhzn "
+"	ORDER BY mukey, cokey, chkey "

+"	SELECT mukey, cokey, restrictiodepth, "
+"	CAST(sum(thickness) AS float(2)) AS sum_thickness, "
+"	CAST(sum(th_awc_r) AS float(2)) AS sum_awc_r "
+"	INTO #acpf4 "
+"	FROM #acpf3 "
+"	GROUP BY mukey, cokey, restrictiodepth "
+"	ORDER BY mukey "

+"	SELECT mukey, cokey, CASE WHEN sum_thickness < restrictiodepth then sum_thickness  else restrictiodepth end AS restrictiondepth "
+"	INTO #depthtest "
+"	FROM #acpf4 "

+"	SELECT #acpf4.mukey, #acpf4.cokey, "
+"	 sum_thickness, "
+"	 #depthtest.restrictiondepth, "
+"	(sum_awc_r) AS profile_Waterstorage, "
+"	(sum_awc_r/#depthtest.restrictiondepth)  AS wtavg_awc_r_to_restrict "
+"	INTO #acpfwtavg "
+"	FROM #acpf4  "
+"	INNER JOIN #depthtest on #acpf4.cokey=#depthtest.cokey "
+"	ORDER by #acpf4.mukey, #acpf4.cokey "

+"	SELECT DISTINCT "
+"	  #acpf.state, "
+"	  #acpf.areasymbol, "
+"	  #acpf.areaname, "
+"	  #acpf.musym, "
+"	  #acpf.mukey, "
+"	  #acpf.cokey, "
+"	  #acpf.muname, "
+"	  majcompflag, "
+"	  comppct_r, "
+"	  #acpf.compname, "
+"	  compkind, "
+"	  localphase, "
+"	  slope_l, "
+"	  slope_r, "
+"	  slope_h, "
+"	  CAST(aws100 AS Decimal(5,1)) AS aws100_dcp, "
+"		CAST(aws_0_20 AS Decimal(5,1)) AS aws_0_20_dcp, "
+"			CAST(aws_20_50 AS Decimal(5,1)) AS aws_20_50_dcp, "
+"				CAST(aws_50_100 AS Decimal(5,1)) AS aws_50_100_dcp, "
+"	  CAST(profile_Waterstorage AS Decimal(5,1)) AS AWS_profile_dcp, "
+"	  CAST(wtavg_awc_r_to_restrict AS Decimal(5,1)) AS AWS_restrict_dcp, "
+"	  sum_thickness, "
+"	  CAST(#acpfwtavg.restrictiondepth/2.54 AS int)  restrictiondepth_IN, "
+"	  #acpfwtavg.restrictiondepth, "
+"	  TOPrestriction, "
+"	  #acpf2.chkey, "
+"	  #acpf2.hzname, "
+"	CAST(#acpf2.hzdept_r/2.54 AS int)  AS hzdept_r, "
+"	CAST(#acpf2.hzdepb_r/2.54 AS int) AS hzdeb_r "
+"	INTO #alldata "
+"	FROM #acpf2 "
+"	INNER JOIN #acpf on #acpf.cokey = #acpf2.cokey  "
+"	LEFT OUTER JOIN #aws100 on #acpf.cokey = #aws100.cokey "
+"	LEFT OUTER JOIN #acpfwtavg on #acpf.cokey = #acpfwtavg.cokey "
+"	ORDER BY #acpf.state, #acpf.areasymbol, #acpf.areaname, #acpf.musym "

+"	SELECT #main.musym, #main.muname,  #main.compname, #main.comppct_r, MIN_Wet,  #alldata.aws100_dcp , #main.mukey, "
+"	CASE WHEN annflodfreq = 'Frequent' THEN 1 "
+"	WHEN annflodfreq = 'Very frequent' THEN 1 ELSE 0 END AS ffreq, "
+"	CASE WHEN  annfloddur = 'Long (7 to 30 days)' THEN 1 "
+"	WHEN annfloddur = 'Very long (more than 30 days)' THEN 1 ELSE 0 END AS fdur, taxorder, taxsuborder, "
+"	#main.cokey "
+"	INTO #laststep "
+"	FROM #main "
+"	LEFT OUTER JOIN #alldata ON #alldata.cokey=#main.cokey "
+"	INNER JOIN #wet ON #wet.cokey=#main.cokey  "
+"	ORDER BY #main.muname, #main.musym, #main.comppct_r DESC, #main.compname, #main.cokey "

+"	SELECT mukey, cokey, musym AS 'Mapunit Symbol', muname AS 'Mapunit Name',  compname AS 'Component Name', comppct_r AS 'Component Percent', MIN_Wet AS 'Depth to Wetness (cm)',  aws100_dcp AS 'Available Water Storage (100 cm)' , "
+"	ffreq + fdur AS 'Flooding (freq/dur)', taxsuborder, "
+"	CASE WHEN taxorder = 'Histosols' AND MIN_Wet <= 30 THEN 'wet' "
+"  WHEN MIN_Wet <= 30 THEN 'Wet'"
+"	WHEN ffreq = 1 AND fdur = 1 THEN 'wet' "
+"	WHEN LEFT (taxsuborder,3) = 'Aqu' AND aws100_dcp  >= 15.24 THEN 'wet-mesic' "
+"	WHEN MIN_Wet BETWEEN 30 AND 91  AND aws100_dcp  >= 15.24  THEN 'wet-mesic' "
+"	WHEN aws100_dcp  >= 15.24 THEN 'mesic' "
+"	WHEN LEFT (taxsuborder,3) = 'Aqu' AND aws100_dcp  < 15.24 THEN 'mesic' "
+"	WHEN MIN_Wet BETWEEN 30 AND 91  AND aws100_dcp  < 15.24  THEN 'mesic' "
+"	WHEN aws100_dcp BETWEEN 7.62 AND 15.24 THEN 'dry-mesic' "
+"	WHEN aws100_dcp  < 7.62 THEN  'dry' ELSE 'N/A' "
+"	END AS 'Soil Moisture Site Condition' "
+"	FROM #laststep "
+"	ORDER BY muname, musym, comppct_r DESC, compname, cokey "











;
				
				
				var data = {
				query: query,
				format: "json+columnname"
			}
			
			$.post(url, data, function( callbackData ) {
				// the success callback function: when executed add content to table
					$('#id1')[0].innerHTML = "";
					var tableHtml = '<table border="1">';
			// for each row...
			var iRow = 0;
                while (iRow < callbackData.Table.length) {
                                var row = callbackData.Table[iRow];
                                tableHtml += "<tr>";
                                // for each column in each row...
                                var iCol = 0;
                                while (iCol < row.length) {
                                                if (iRow == 0) {
                                                                tableHtml += "<th>" + row[iCol] + "</th>";
                                                } else {
                                                                tableHtml += "<td>" + row[iCol] + "</td>";
                                                }
                                                iCol++;
                                };
                                tableHtml += "</tr>";                                  
                                iRow++;
                };

					tableHtml += '</table>'
					$('#id1').append(tableHtml);
				}, 
				// Specify that we want the request to be sent in JSON format
				"json");			
			
				
		}
	</script>
	<script>
$(function(){
	$('table').each(function() {
		if($(this).find('thead').length > 0 && $(this).find('th').length > 0) {
			// Clone <thead>
			var $w	   = $(window),
				$t	   = $(this),
				$thead = $t.find('thead').clone(),
				$col   = $t.find('thead, tbody').clone();

			// Add class, remove margins, reset width and wrap table
			$t
			.addClass('sticky-enabled')
			.css({
				margin: 0,
				width: '100%'
			}).wrap('<div class="sticky-wrap" />');

			if($t.hasClass('overflow-y')) $t.removeClass('overflow-y').parent().addClass('overflow-y');

			// Create new sticky table head (basic)
			$t.after('<table class="sticky-thead" />');

			// If <tbody> contains <th>, then we create sticky column and intersect (advanced)
			if($t.find('tbody th').length > 0) {
				$t.after('<table class="sticky-col" /><table class="sticky-intersect" />');
			}

			// Create shorthand for things
			var $stickyHead  = $(this).siblings('.sticky-thead'),
				$stickyCol   = $(this).siblings('.sticky-col'),
				$stickyInsct = $(this).siblings('.sticky-intersect'),
				$stickyWrap  = $(this).parent('.sticky-wrap');

			$stickyHead.append($thead);

			$stickyCol
			.append($col)
				.find('thead th:gt(0)').remove()
				.end()
				.find('tbody td').remove();

			$stickyInsct.html('<thead><tr><th>'+$t.find('thead th:first-child').html()+'</th></tr></thead>');
			
			// Set widths
			var setWidths = function () {
					$t
					.find('thead th').each(function (i) {
						$stickyHead.find('th').eq(i).width($(this).width());
					})
					.end()
					.find('tr').each(function (i) {
						$stickyCol.find('tr').eq(i).height($(this).height());
					});

					// Set width of sticky table head
					$stickyHead.width($t.width());

					// Set width of sticky table col
					$stickyCol.find('th').add($stickyInsct.find('th')).width($t.find('thead th').width())
				},
				repositionStickyHead = function () {
					// Return value of calculated allowance
					var allowance = calcAllowance();
				
					// Check if wrapper parent is overflowing along the y-axis
					if($t.height() > $stickyWrap.height()) {
						// If it is overflowing (advanced layout)
						// Position sticky header based on wrapper scrollTop()
						if($stickyWrap.scrollTop() > 0) {
							// When top of wrapping parent is out of view
							$stickyHead.add($stickyInsct).css({
								opacity: 1,
								top: $stickyWrap.scrollTop()
							});
						} else {
							// When top of wrapping parent is in view
							$stickyHead.add($stickyInsct).css({
								opacity: 0,
								top: 0
							});
						}
					} else {
						// If it is not overflowing (basic layout)
						// Position sticky header based on viewport scrollTop
						if($w.scrollTop() > $t.offset().top && $w.scrollTop() < $t.offset().top + $t.outerHeight() - allowance) {
							// When top of viewport is in the table itself
							$stickyHead.add($stickyInsct).css({
								opacity: 1,
								top: $w.scrollTop() - $t.offset().top
							});
						} else {
							// When top of viewport is above or below table
							$stickyHead.add($stickyInsct).css({
								opacity: 0,
								top: 0
							});
						}
					}
				},
				repositionStickyCol = function () {
					if($stickyWrap.scrollLeft() > 0) {
						// When left of wrapping parent is out of view
						$stickyCol.add($stickyInsct).css({
							opacity: 1,
							left: $stickyWrap.scrollLeft()
						});
					} else {
						// When left of wrapping parent is in view
						$stickyCol
						.css({ opacity: 0 })
						.add($stickyInsct).css({ left: 0 });
					}
				},
				calcAllowance = function () {
					var a = 0;
					// Calculate allowance
					$t.find('tbody tr:lt(3)').each(function () {
						a += $(this).height();
					});
					
					// Set fail safe limit (last three row might be too tall)
					// Set arbitrary limit at 0.25 of viewport height, or you can use an arbitrary pixel value
					if(a > $w.height()*0.25) {
						a = $w.height()*0.25;
					}
					
					// Add the height of sticky header
					a += $stickyHead.height();
					return a;
				};

			setWidths();

			$t.parent('.sticky-wrap').scroll($.throttle(250, function() {
				repositionStickyHead();
				repositionStickyCol();
			}));

			$w
			.load(setWidths)
			.resize($.debounce(250, function () {
				setWidths();
				repositionStickyHead();
				repositionStickyCol();
			}))
			.scroll($.throttle(250, repositionStickyHead));
		}
	});
});
</script>
</body>
</html>